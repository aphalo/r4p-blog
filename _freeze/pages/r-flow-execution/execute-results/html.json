{
  "hash": "31c9355b2fcc86a1a3b49c2e2c9a7e81",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Flow of code execution\"\nsubtitle: \"R language constructs for flow control\"\nauthor: \"Pedro J. Aphalo\"\ndate: \"2023-11-18\"\ndate-modified: \"2023-11-18\"\nformat:\n  html:\n    mermaid:\n      theme: neutral\ncode-fold: show\ncallout-icon: false\nengine: knitr\nfilters:\n  - webr\neditor: \n  markdown: \n    wrap: 72\nabstract: |\n  Interactive examples and flow chart diagrams for R language constructs for conditional evaluation and for repeated evaluation of code statements.\n---\n\n\n# Introduction\n\nIn a simple script the code statements are run (= executed, = evaluated)\none after another as they appear in the file, from top to bottom. A\nsimple script then always runs the same statements carrying out each\ntime the script is run the same computations.\n\nThis restriction is removed by including *control constructs* that based\non a test condition decide which code statement to run next. Using this\nconstructs we can make the computations done depend on data and their\nproperties. This is when programming starts being most useful or\n\"powerful\", because the same code in scripts (or packages) becomes\nuseful with many different datasets.\n\nWe can group these constructs used to control the flow of code execution\nfrom statement to statement in two groups: those that work as ON/OFF\nswitches and those that implement the repeated execution of a statement,\nor *iteration*.\n\nTo make this work usefully, we need one more construct: a construct to\nassemble a compound code statement from multiple simple code statements.\nThis makes it possible for the *control constructs* mentioned above to\ncontrol groups of statements or \"chunks\" of code in addition to simple\nstatements.\n\nBelow, we start with the sequential execution of statements in their\n\"natural\" ordering and grouping into compound statements. Next, we look\nand the ON/OFF or YES/NO constrtucts (`if`, `if ... else` and `ifelse`).\nLast we look at the *iteration* or \"repeated execution\" *control\nconstructs* (`for ()`, `while()` and `repeat`).\n\n::: callout-tip\n# {{< bi keyboard-fill >}} Playgrounds or interactive R examples\n\nWithin this page you will run R examples in the web browser. You can\nedit these code examples and run them again as many times as you like,\nby clicking on the **Run Code** button above the 'WebR' text panels.\n:::\n\n# Unconditional execution\n\n## Sequence\n\n![Flow diagram of sequential evaluation of code\nstatements](r-flow-figures/sequence.png){fig-alt=\"A flow chart\"\nfig-align=\"center\" width=\"25%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 123\nb <- a * 2\nprint(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 246\n```\n\n\n:::\n:::\n\n\n::: callout-tip\n# {{< bi keyboard-fill >}} Playground\n\n```{webr-r}\na <- 123\nb <- a * 2\nprint(b)\n```\n:::\n\n## Compound statement\n\n![A compound statement containing two statements and their sequence of\nevaluation..](r-flow-figures/compound.png){fig-alt=\"Flow chart showing two code statements enclosed within a box.\"\nfig-align=\"center\" width=\"30%\"}\n\nA group code statements enclosed in `{ }` conform a compoud statement.\nBy itself this construct does not modify the sequence in which\nstatements are executed or evaluated.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 123\n{\n  b <- a * 2\n  print(b)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 246\n```\n\n\n:::\n:::\n\n\n::: callout-tip\n# {{< bi keyboard-fill >}} Playground\n\n```{webr-r}\na <- 123\n{\n  b <- a * 2\n  print(b)\n}\n```\n:::\n\n# Conditional execution\n\nDecisions about which statement to run next are based on the result of a\ntest returning a `logical` value, TRUE`or`FALSE\\`.\n\n## `if ()` statement\n\n![Flow diagram of an \\`if ()\\` control construct showing the alternative\npaths of\nevalaution.](r-flow-figures/if.png){fig-alt=\"A flow chart showing two alternative paths downstream of a decision.\"\nfig-align=\"center\" width=\"67%\"}\n\nIn an `if` statement, the decision is based on the value of a `logical`\nvector of length one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 123\nif (a > 0) {\n  print(\"'a' is positive\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"'a' is positive\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 123\n```\n\n\n:::\n:::\n\n\n::: callout-tip\n# {{< bi keyboard-fill >}} Playground\n\n```{webr-r}\na <- 123\nif (a > 0) {\n  print(\"'a' is positive\")\n}\nprint(a)\n```\n\n```{webr-r}\na <- c(1, 2, 3) # a vector of length 3\nif (all(a > 0)) { # logical of length == 1 \n  print(\"All 'a[i]' are positive\")\n}\nprint(a)\n```\n:::\n\n## `if ()... else` statement\n\n![Flow diagram of an \\`if ()\\` control construct showing the alternative\npaths of\nevaluation.](r-flow-figures/if_else.png){fig-alt=\"Flow chart with two paths downstream of the decision.\"\nfig-align=\"center\" width=\"95%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 123\nif (a >= 0) {\n  print(\"'a' is positive\")\n} else {\n  print(\"'a' is negative\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"'a' is positive\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 123\n```\n\n\n:::\n:::\n\n\n::: callout-tip\n# {{< bi keyboard-fill >}} Playground\n\n```{webr-r}\na <- 123\nif (a >= 0) {\n  print(\"'a' is positive\")\n} else {\n  print(\"'a' is negative\")\n}\nprint(a)\n```\n\nFor dealing with vectors longer that one we can use `all()` and `any()`.\nOf course, if they describe the decision we need to process our data.\n\n```{webr-r}\na <- c(1, 2, 3) # a vector of length 3\nif (all(a > 0)) { # logical of length == 1 \n  print(\"All 'a[i]' are positive\")\n} else {\n  print(\"One or more 'a[i]' are negative\")\n}\nprint(a)\n```\n\nAn advanced/more sophisticated alternative is to count the number of\nmembers in the vector that are positive and negative.\n\n```{webr-r}\na <- c(1, 2, 3) # a vector of length 3\nif (all(a >= 0)) {\n  print(\"All 'a[i]' are positive\")\n} else if (all(a < 0)) {\n  print(\"All 'a[i]' are negative\")\n} else {\n  print(paste(\"'a' contains\", \n              sum(a >= 0), \"positive and\", \n              sum(a < 0), \"negative values.\"))\n}\nprint(a)\n```\n:::\n\n## `switch` statement\n\nIn a switch statement the decision selects the evaluation of one among\nmultiple alternative staements. The \"selector\" can be an integer or a\ncharacter vector of length equal to one.\n\n![Flow diagram showing multiple alternative code statements with\nevaluation controlled by a \\`switch()\\`\nstatement.](r-flow-figures/switch.png){fig-alt=\"Flow chart with multiple parallel paths for evaluation.\"\nfig-align=\"center\" width=\"80%\"}\n\nUsing names for the _cases_ in the switch.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.char <- \"two\"\nmy.fraction <- switch(my.char,\n                      one = 1,\n                      two = 1 / 2,\n                      four = 1 / 4,\n                      0\n)\nprint(my.fraction)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5\n```\n\n\n:::\n:::\n\n\n::: callout-tip\n# {{< bi keyboard-fill >}} Playground\n\n```{webr-r}\nmy.char <- \"two\"\nmy.number <- switch(my.char,\n                    one = 1,\n                    two = 2,\n                    four = 4,\n                    0\n)\nprint(my.number)\n```\n\n\n```{webr-r}\nmy.char <- \"dos\"\nmy.number <- switch(my.char,\n                    one =, uno = 1,\n                    two =, dos = 2,\n                    four =, cuatro = 4,\n                    0\n)\nprint(my.number)\n```\n:::\n\nUsing numbers to select cases by position.\n\n::: callout-tip\n# {{< bi keyboard-fill >}} Playground\n\n```{webr-r}\nmy.number <- 2\nmy.char <- switch(my.number,\n                  \"one\",\n                  \"two\",\n                  \"three\", # needed!!\n                  \"four\",\n                  \"not one, two or four\"\n)\nprint(my.char)\n```\n:::\n\n## `ifelse(...)` *vectorised* statement\n\nFunction `ifelse()` works very differently than `if () ... else`. The\ndecision can, and in most cases, it is based on a long logical vector.\nThe returned value has the same length as the `logical` vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(1, 2, -1, 3) # a vector of length 3\nifelse(a >= 0, \"positive\", \"negative\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"positive\" \"positive\" \"negative\" \"positive\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  2 -1  3\n```\n\n\n:::\n:::\n\n\n::: callout-tip\n# {{< bi keyboard-fill >}} Playground\n\n```{webr-r}\na <- 123\nifelse(a >= 0, \"positive\", \"negative\")\nprint(a)\n```\n\n```{webr-r}\na <- c(1, 2, -1, 3)\nifelse(a >= 0, \"positive\", \"negative\")\nprint(a)\n```\n:::\n\n# Iteration or repeated execution\n\n## `for ()` statement\n\n![Flow diagram of a \\`for ()\\` loop, showing the compound statement that\nis evaluated\nrepeatedly.](r-flow-figures/for.png){fig-alt=\"Flow chart showing a closed execution path with an entry and an exit.\"\nfig-align=\"center\" width=\"70%\"}\n\nIn a `for` statement, the controlled statement is run with one member of\na list or vector at a time, normally walking from \"head\" to \"tail\" of\nthe list or vector. The value of each member is accessed through a\n\"place holder\" variable. The name of the arbitrary variable can be any\nvalid R name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(1, 2, -1, 3)\nfor (a_member in a) {\n  print(a_member)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] -1\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  2 -1  3\n```\n\n\n:::\n:::\n\n\n::: callout-tip\n# {{< bi keyboard-fill >}} Playground\n\n```{webr-r}\na <- c(1, 2, -1, 3)\nfor (a_member in a) {\n  print(a_member)\n}\nprint(a)\n```\n\nUsing extraction operator `[ ]` and indexing.\n\n```{webr-r}\na <- c(1, 2, -1, 3)\nsum_of_a <- 0\nfor (i in seq_along(a)) {\n  sum_of_a <- sum_of_a + a[i]\n  print(sum_of_a)\n}\nprint(a)\n```\n\nWe can end early.\n\n```{webr-r}\na <- c(1, 2, -1, 3)\nfor (a_member in a) {\n  if (a_member < 0) {\n    break()\n  }\n  print(a_member)\n}\nprint(a)\n```\n\nWe can jump to the next.\n\n```{webr-r}\na <- c(1, 2, -1, 3)\nfor (a_member in a) {\n  if (a_member < 0) {\n    next()\n  }\n  print(a_member)\n}\nprint(a)\n```\n:::\n\n## `while()` statement\n\n![Flow diagram of an \\`while()\\` control construct showing the closed\nloop containing a statement repeatedly\nevaluated.](r-flow-figures/while.png){fig-alt=\"Flow chart with a closed loop with an entry and an exit point.\"\nfig-align=\"center\" width=\"70%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(1, 2, -1, 3)\ni <- 0\nsum_of_a <- 0\nwhile(i < length(a)) {\n  i <- i + 1\n  sum_of_a <- sum_of_a + a[i]\n  print(sum_of_a)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 3\n[1] 2\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n::: callout-tip\n# {{< bi keyboard-fill >}} Playground\n\n```{webr-r}\na <- c(1, 2, -1, 3)\ni <- 0\nsum_of_a <- 0\nwhile(sum_of_a < 2) {\n  i <- i + 1\n  sum_of_a <- sum_of_a + a[i]\n  print(sum_of_a)\n}\nprint(i)\n```\n\n```{webr-r}\na <- c(1, 2, -1, 3)\ni <- 1\nsum_of_a <- 0\nwhile(sum_of_a < 2) {\n  sum_of_a <- sum_of_a + a[i]\n  print(sum_of_a)\n  i <- i + 1\n}\nprint(i)\n```\n:::\n\n## `repeat` statement\n\n![Flow diagram of an \\`repeat\\` control construct showing one statement\nrepeatedly evaluated in a loop-shaped\npath](r-flow-figures/repeat.png){fig-alt=\"Flow chart with a loop with an exit point at an arbitrary point within the loop.\"\nfig-align=\"center\" width=\"70%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(1, 2, -1, 3)\ni <- 0\nsum_of_a <- 0\nwhile(i < length(a)) {\n  i <- i + 1\n  sum_of_a <- sum_of_a + a[i]\n  print(sum_of_a)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 3\n[1] 2\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n::: callout-tip\n# {{< bi keyboard-fill >}} Playground\n\n```{webr-r}\na <- c(1, 2, -1, 3)\ni <- 0\nsum_of_a <- 0\nrepeat {\n  if (sum_of_a >= 2) {\n    break()\n  }\n  i <- i + 1\n  sum_of_a <- sum_of_a + a[i]\n  print(sum_of_a)\n}\nprint(i)\n```\n\n```{webr-r}\na <- c(1, 2, -1, 3)\ni <- 1\nsum_of_a <- 0\nrepeat {\n  sum_of_a <- sum_of_a + a[i]\n  print(sum_of_a)\n  if (sum_of_a >= 2) {\n    break()\n  }\n  i <- i + 1\n}\nprint(i)\n```\n\n:::\n\n# Take home message\n\nNow you know all the important constructs that make it possible to control the flow of evaluation of statements in a script or program. With small variations in their syntax, these same constructs are available in many different computer programming languages.\n\nThat all these constructs are available in R, makes of R a proper programming language. **It also means that learning to program in additional computer languages is much easier than learning the first one.**\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}