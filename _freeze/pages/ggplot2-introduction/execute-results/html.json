{
  "hash": "9ab606ccd29d51445c25830bea16da76",
  "result": {
    "markdown": "---\ntitle: \"'ggplot2' basics (DRAFT)\"\nsubtitle: \"The Layeerd Grammar of Graphics\"\nauthor: \"Pedro J. Aphalo\"\ndate: 2022-05-03\ndate-modified: 2023-05-03\ncategories: [R, plotting]\nkeywords: [ggplot2 pkg, data visualization, dataviz]\ncode-fold: false\n---\n\n\n::: callout-warning\nPackage ['ggplot2'](https://ggplot2.tidyverse.org/) has gained new features over its long life, and although few changes have been 'code brealking' you should be aware that the examples in this page have been tested with version (==3.4.2).\n:::\n\n## Layered Grammar of Graphics\n\nIt is best to think of 'ggplot2' and its extensions as a language used to specify how to build a plot. This language gives access to an abstraction about about the structure of data plots and how to assemble this structure. This is the most important aspect of learning to create ggplots. Once one grasps the general picture, what remains is just the choice among different \"building blocks\", as building blocks of the same \"kind\" can in most cases replace each other, differing drastically in the graphical output, but minimally in how they are added to a plot.\n\n::: callout-note\nI consider packages like 'ggrepel', 'ggpmisc', and 'ggbeeswarm' that provide extensions to the grammar, as extensions to package 'ggplot2'. Some packages like 'ggpubr' mostly define functions that build whole plots using 'ggplot2' and return 'gg' objects, but are designed to be used on their own. Such functions do not extend the grammar of graphics, they define their own user interface. Package 'ggspectra' has double personality as it extends the grammar but also defines special `autoplot()` methods for spectra. It remains consistent with 'ggplot2' because the generic method `autoplot()` is defined by package 'ggplot2'.\n:::\n\n## The main steps\n\nDifferently to many other data plotting approaches, ggplots are constructed as R objects. So ploting data consists in the following sequence of events. Building an object that can be stored and rendered as a graphical representation at every single step of its construction has two main advantages: 1) we can save parts of the object and reuse them, and 2) we can build a plot bit by bit check the effect of each addition on the plot. It is possible, but infrequently needed, to edit an existing ggplot object: one can add, remove and replace components and also change the order of the layers. In most cases it is easier to edit the code used to create the plot, but if one does not have access to the original code or data, editing a ggplot can save the day. Editing is also an effective way of learning the _internals_ of ggplots if one is interested. My package 'gginnards' makes editing easier. I developed to help me learn how 'ggplot2' works and to debug the code in my other packages with extensions to 'ggplot2'.\n\nThe steps are:\n\n1.    Build an R object with data and instructions for making the plot.\n\n1.    (Possibly add to or even \"edit\" the R object).\n\n2.    \"Render\" the plot (convert it into a graphical object).\n\n3.    Display the graphical object or save it in a file.\n\n## The layers\n\nWe can use different abstractions to describe a plot, both static and dynamic. A plot can be thought as a stack of layers each drawn on a transparent substrate. What we draw first may be occluded by something we draw on top of it. When we construct a ggplot we build complex plots layer by layer, even if not drawn at the time we add them, they will be rendered into graphical objects in the order we have added them to the object. This abstraction based on layer is the key to the flexibility of ggplots: we can build an almost infinite variety of plots by combining different layers, each one of them, quite simple and with an easy to understand role. In reality, we can also adjust things to an extent within each layer. Not only functions defined in 'ggplot2' can add layers to ggplots but also layer functions defined in other R packages or by the user.\n\n## The data flow\n\nI consider now, a dynamic abstraction, the data flow describing what transformations are applied to the data in different components of a ggplot. These transformations take place when the plot is rendered, not when it is built, and take place separately in each layer. A ggplot object contains data but also functions that describe the operations to be carried on the data during rendering.\n\n\n```{mermaid}\n%%| label: fig-layer-data-flow\n%%| fig-cap: Data flow in a single plot layer. ggplot objects can contain zero, one, or more layers.\n%%| fig-align: center\nflowchart LR\n  A(Layer data) --> B[statistic] --> C[geometry] --> D[layer 'grobs']\n  A -.-> b[identity\\nstatistic] -.-> C\n```\n\n\nThe data in a ggplot can be shared among all or some layers or be different for each layer. What gets combined are the graphical objects, or instructions to draw features in the final plot. Not yet the plot itself, which is rendered by R graphic devices into any of the format supported by R.\n\n\n```{mermaid}\n%%| label: fig-plot-default-data-flow\n%%| fig-cap: Data flow in a plot containing three layers, sharing the same data. The geoms during plot rendering output graphical objects, or \"plot drawing instructions\". The final rendering into a specific file or screen format is done by R's graphic devices, not by code in the 'ggplot2' package.\n%%| fig-align: center\nflowchart LR\n  A(Plot data) --> B1[statistic 1] --> C1[geometry 1] --> D[layer 1 'grobs'\\nlayer 2 'grobs'\\nlayer 3 'grobs']\n  A--> B2[statistic 2] --> C2[geometry 2] --> D \n  A--> B3[statistic 3] --> C3[geometry 3] --> D \n  D --> E1(computer screen)\n  D -.-> E2(PDF file)\n  D -.-> E3(EPS file)\n  D -.-> E4(JPEG file)\n  D -.-> E5(SVG file)\n  D -.-> E6(PNG file)\n  D -.-> E7(TIFF file)\n```\n\n```{mermaid}\n%%| label: fig-plot-layer-data-flow\n%%| fig-cap: Data flow in a plot containing two layers, each one with different data. See legend to @fig-plot-default-data-flow for details.\n%%| fig-align: center\nflowchart LR\n  A1(Layer 1 data) --> B1[statistic 1] --> C1[geometry 1] --> D[layer 1 'grobs'\\nlayer 2 'grobs']\n  A2(Layer 2 data) --> B2[statistic 2] --> C2[geometry 2] --> D \n  D --> E1(computer screen)\n  D -.-> E2(PDF file)\n  D -.-> E3(EPS file)\n  D -.-> E4(JPEG file)\n  D -.-> E5(SVG file)\n  D -.-> E6(PNG file)\n  D -.-> E7(TIFF file)\n```\n\n\nAs with all abstractions, the simple diagrams and explanations above ignored the real complexity. One of the ignored steps is crucial: how information in the data is encoded as graphical elements drawn in the plot, and how can we control this step.\n\n## Building a plot step by step\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(scales)\nlibrary(ggplot2)\nlibrary(gginnards)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot()\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars)\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg))\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg)) +\n  geom_point(color = \"red\", shape = \"square\")\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg)) +\n  geom_point() +\n  stat_smooth(geom = \"line\", method = \"lm\", formula = y ~ x)\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg)) +\n  geom_point() +\n  stat_smooth(geom = \"line\", method = \"lm\", formula = y ~ x) +\n  scale_y_log10()\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg)) +\n  geom_point() +\n  stat_smooth(geom = \"line\", method = \"lm\", formula = y ~ x) +\n  coord_cartesian(ylim = c(15, 25))\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg)) +\n  geom_point() +\n  stat_smooth(geom = \"line\", method = \"lm\", formula = y ~ x) +\n  coord_trans(y = \"log10\")\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg)) +\n  geom_point() +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg)) +\n  geom_point() +\n  theme_classic(base_size = 20, base_family = \"serif\")\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg)) +\n  geom_point() +\n  labs(x = \"Engine displacement (cubic inches)\",\n       y = \"Fuel use efficiency\\n(miles per gallon)\",\n       title = \"Motor Trend Car Road Tests\",\n       subtitle = \"Source: 1974 Motor Trend US magazine\")\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars, aes(x = disp / cyl, y = mpg)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n## The internals\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- ggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point()\nsummary(p)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndata: manufacturer, model, displ, year, cyl, trans, drv, cty, hwy, fl,\n  class [234x11]\nmapping:  x = ~displ, y = ~hwy\nfaceting: <ggproto object: Class FacetNull, Facet, gg>\n    compute_layout: function\n    draw_back: function\n    draw_front: function\n    draw_labels: function\n    draw_panels: function\n    finish_data: function\n    init_scales: function\n    map_data: function\n    params: list\n    setup_data: function\n    setup_params: function\n    shrink: TRUE\n    train_scales: function\n    vars: function\n    super:  <ggproto object: Class FacetNull, Facet, gg>\n-----------------------------------\ngeom_point: na.rm = FALSE\nstat_identity: na.rm = FALSE\nposition_identity \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(p, max.level = 1, list.len = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nObject size: 29.3 kB\nList of 9\n $ data       : tibble [234 × 11] (S3: tbl_df/tbl/data.frame)\n $ layers     :List of 1\n $ scales     :Classes 'ScalesList', 'ggproto', 'gg' <ggproto object: Class ScalesList, gg>\n    add: function\n    clone: function\n    find: function\n    get_scales: function\n    has_scale: function\n    input: function\n    n: function\n    non_position_scales: function\n    scales: list\n    super:  <ggproto object: Class ScalesList, gg> \n $ mapping    :List of 2\n  [list output truncated]\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(p$layers, max.level = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 1\n $ :Classes 'LayerInstance', 'Layer', 'ggproto', 'gg' <ggproto object: Class LayerInstance, Layer, gg>\n    aes_params: list\n    compute_aesthetics: function\n    compute_geom_1: function\n    compute_geom_2: function\n    compute_position: function\n    compute_statistic: function\n    computed_geom_params: NULL\n    computed_mapping: NULL\n    computed_stat_params: NULL\n    constructor: call\n    data: waiver\n    draw_geom: function\n    finish_statistics: function\n    geom: <ggproto object: Class GeomPoint, Geom, gg>\n        aesthetics: function\n        default_aes: uneval\n        draw_group: function\n        draw_key: function\n        draw_layer: function\n        draw_panel: function\n        extra_params: na.rm\n        handle_na: function\n        non_missing_aes: size shape colour\n        optional_aes: \n        parameters: function\n        rename_size: FALSE\n        required_aes: x y\n        setup_data: function\n        setup_params: function\n        use_defaults: function\n        super:  <ggproto object: Class Geom, gg>\n    geom_params: list\n    inherit.aes: TRUE\n    layer_data: function\n    map_statistic: function\n    mapping: NULL\n    position: <ggproto object: Class PositionIdentity, Position, gg>\n        compute_layer: function\n        compute_panel: function\n        required_aes: \n        setup_data: function\n        setup_params: function\n        super:  <ggproto object: Class Position, gg>\n    print: function\n    setup_layer: function\n    show.legend: NA\n    stat: <ggproto object: Class StatIdentity, Stat, gg>\n        aesthetics: function\n        compute_group: function\n        compute_layer: function\n        compute_panel: function\n        default_aes: uneval\n        dropped_aes: \n        extra_params: na.rm\n        finish_layer: function\n        non_missing_aes: \n        optional_aes: \n        parameters: function\n        required_aes: \n        retransform: TRUE\n        setup_data: function\n        setup_params: function\n        super:  <ggproto object: Class Stat, gg>\n    stat_params: list\n    super:  <ggproto object: Class Layer, gg> \n```\n:::\n:::\n",
    "supporting": [
      "ggplot2-introduction_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}