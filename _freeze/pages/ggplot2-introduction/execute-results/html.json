{
  "hash": "3f3cae3192c394271c912d57c143be9e",
  "result": {
    "markdown": "---\ntitle: \"'ggplot2' Basics\"\nsubtitle: \"The Layered Grammar of Graphics\"\nauthor: \"Pedro J. Aphalo\"\ndate: 2022-05-03\ndate-modified: 2023-05-13\ncategories: [R, plotting]\nkeywords: [ggplot2 pkg, data visualization, dataviz]\ncode-fold: false\n---\n\n\n::: callout-warning\nPackage ['ggplot2'](https://ggplot2.tidyverse.org/) has gained new features over its long life, and although few changes have been 'code brealking' you should be aware that the examples in this page have been tested with version (==3.4.2).\n:::\n\n## Layered Grammar of Graphics\n\nIt is best to think of 'ggplot2' and its extensions as a language used to specify how to build a plot. This language gives access to an abstraction about about the structure of data plots and how to assemble this structure. This is the most important aspect of learning to create ggplots. Once one grasps the general picture, what remains is just the choice among different \"building blocks\", as building blocks of the same \"kind\" can in most cases replace each other, differing drastically in the graphical output, but minimally in how they are added to a plot.\n\n::: callout-note\nI consider packages like 'ggrepel', 'ggpmisc', and 'ggbeeswarm' that provide extensions to the grammar, as extensions to package 'ggplot2'. Some packages like 'ggpubr' mostly define functions that build whole plots using 'ggplot2' and return `\"gg\"` objects, but are designed to be used on their own. Such functions do not extend the grammar of graphics, they define their own user interface. Package 'ggspectra' has double personality as it extends the grammar but also defines special `autoplot()` methods for spectra. It remains consistent with 'ggplot2' because the generic method `autoplot()` is defined in package 'ggplot2'.\n:::\n\n## The main steps\n\nDifferently to many other data plotting approaches, ggplots are constructed as R objects. So plotting data consists in a constructing an object of class `\"gg\"` followed by its rendering. As any R object, `\"gg\"` objects can be stored in variables and can be printed to display them. When printed ggplots are rendered by default as a graphical representation, however they can also be displayed as text to reveal their structure. That both representations can be obtained at each step of their construction and that `\"gg\"` objects can be built by the succesive addition of components has two main advantages: 1) we can save parts of a `\"gg\"` object and reuse them, and 2) we can build a plot bit by bit and check the effect of each addition to the `\"gg\"` objects. It is possible, but infrequently needed, to edit an existing ggplot object: one can add, remove and replace components and also change the order of the layers. In most cases it is easier to edit the code used to create the plot, but if one does not have access to the original code or data, editing a ggplot can save the day. Editing is also an effective way of learning the _internals_ of ggplots if one is interested in them. My package 'gginnards' makes editing easier. I developed this pacakge to help me learn how 'ggplot2' works and to debug the code in my other packages with extensions to 'ggplot2'.\n\nThe steps needed to create a plot using the grammar of graphics are:\n\n1.    Build an R object with data and instructions for making the plot.\n\n1.    (Possibly add to or even \"edit\" the R object).\n\n2.    \"Render\" the plot (convert it into a graphical object).\n\n3.    Display the graphical object or save it in a file.\n\n## The layers\n\nWe can use different abstractions to describe a plot, both static and dynamic. Structurally, a plot can be thought as a stack of graphic layers each drawn on a transparent imaginary substrate. Thus, similarly as when drafting a plot with ink on paper, what we draw first can be occluded by something we draw on top of it. When we build complex plots we construct a `\"gg\"` object layer by layer; these layers even if not drawn at the time we add them, will be rendered into graphical objects in the order we have added them to the `\"gg\"` object. \n\nThe abstraction based on layers is the key to the flexibility of ggplots: we can build an almost infinite variety of plots by combining different layers, each one of them, quite simple and with an easy to understand role. In reality, we can also adjust things to an extent within each layer. Importantly, not only layer functions defined in 'ggplot2' but also layer functions defined in other R packages or in a user script can be used to add layers to ggplots, further expanding the available range of available types of layers.\n\n::: callout-note\nDefining new layer functions is fairly simple as layer functions defined in extension packages or scripts can rely on 'ggplot2' to do most of the work. This suggests that the overwhelming success of 'ggplot2' is similarly to the success of R itself supported by the easy with which new types of plots can be implemented as extensions.\n:::\n\n## The data flow\n\nI consider now, a dynamic abstraction, the data flow describing what transformations are applied to the data in different components of a ggplot (@fig-layer-data-flow). These transformations take place when the plot is rendered, not when it is built, and take place separately in each layer. A ggplot object contains data but also functions that describe the operations to be carried on the data during rendering.\n\n\n```{mermaid}\n%%| label: fig-layer-data-flow\n%%| fig-cap: Data flow in a single plot layer. ggplot objects can contain zero, one, or more layers.\n%%| fig-align: center\nflowchart LR\n  A(Layer data) --> B[statistic] --> C[geometry] --> D[layer 'grobs']\n  A -.-> b[identity\\nstatistic] -.-> C\n```\n\n\nThe data plotted in a ggplot can be shared among all (@fig-plot-default-data-flow) or some layers or be different for each layer (@fig-plot-layer-data-flow). During rendering each layer generates graphical objects (_grobs_ for short) and other code in 'ggplot2' creates the ancillary grobs such as those for the axes, grid, background and legends or keys. When a plot is rendered, all these grobs are collected into an R object, i.e., what code within 'ggplot2' creates are instructions to draw all graphical features in the final plot. Not yet the plot itself, which is in a final step rendered by R's _graphic devices_ into any of the formats supported by R.\n\n\n```{mermaid}\n%%| label: fig-plot-default-data-flow\n%%| fig-cap: Data flow in a plot containing three layers, sharing the same data. The geoms during plot rendering output graphical objects, or \"plot drawing instructions\". The final rendering into a specific file or screen format is done by R's graphic devices, not by code in the 'ggplot2' package.\n%%| fig-align: center\nflowchart LR\n  A(Plot data) --> B1[statistic 1] --> C1[geometry 1] --> D[layer 1 'grobs'\\nlayer 2 'grobs'\\nlayer 3 'grobs']\n  A--> B2[statistic 2] --> C2[geometry 2] --> D \n  A--> B3[statistic 3] --> C3[geometry 3] --> D \n  D --> E1(computer screen)\n  D -.-> E2(PDF file)\n  D -.-> E3(EPS file)\n  D -.-> E4(JPEG file)\n  D -.-> E5(SVG file)\n  D -.-> E6(PNG file)\n  D -.-> E7(TIFF file)\n```\n\n```{mermaid}\n%%| label: fig-plot-layer-data-flow\n%%| fig-cap: Data flow in a plot containing two layers, each one with different data. See legend to @fig-plot-default-data-flow for details.\n%%| fig-align: center\nflowchart LR\n  A1(Layer 1 data) --> B1[statistic 1] --> C1[geometry 1] --> D[layer 1 'grobs'\\nlayer 2 'grobs']\n  A2(Layer 2 data) --> B2[statistic 2] --> C2[geometry 2] --> D \n  D --> E1(computer screen)\n  D -.-> E2(PDF file)\n  D -.-> E3(EPS file)\n  D -.-> E4(JPEG file)\n  D -.-> E5(SVG file)\n  D -.-> E6(PNG file)\n  D -.-> E7(TIFF file)\n```\n\n\nAs with all abstractions, the simple diagrams and explanations above ignored the real complexity. One of the ignored steps is crucial: how information in the data is encoded as graphical elements drawn in the plot, and how can we control this step or _mapping_. In the next section we will build a plot one step at a time. \n\n## Building a plot step by step\n\nBuilding a plot one step at a time, and printing it at each step demonstrates how the grammar of graphics and 'ggplot2' work. The first step is to attach the packages we will use.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(scales)\nlibrary(ggplot2)\nlibrary(gginnards)\n```\n:::\n\n\nAn _empty_ `\"gg\"` object can be rendered as a plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot()\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-5-1.svg)\n:::\n:::\n\n\nWe pass a data frame containing the data to be plotted. As we pass it as an\nargument to `ggplot()` it becomes the default data for the individual layers we\nwill later add. Once a mapping is present, the range of values mapped to each\naesthetic becomes known, and _x_ and _y_ axes are added.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars)\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-6-1.svg)\n:::\n:::\n\n\nThe mapping of variables in the data to plot _aesthetics_ is done with function\n`aes()`.  As we pass the value returned by function `aes()` as an argument to\n`ggplot()` this mapping becomes the default mapping for the individual layers we\nwill later add.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg))\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-7-1.svg)\n:::\n:::\n\n\nGeometries are layer functions, `geom_point()` used here, creates a graphical\nrepresentation of the data as mapped to the _x_ and _y_ aesthetics as symbols or\npoints on the drawing area of the plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-8-1.svg)\n:::\n:::\n\n\nAbove, the shape and colour of the points are the default ones. We can, instead\nof mapping variables to aesthetics, assign constant values to aesthetics. This\nis best done directly as arguments to layer functions as shown here rather than\nusing `aes()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg)) +\n  geom_point(color = \"red\", shape = \"square open\", size = 3)\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-9-1.svg)\n:::\n:::\n\n\nThe default _statistic_ of `geom_point()` is `stat_identity()` that does not\nalter the data. So by default `geom_point()` behaves as is no statistic was\npresent, thus above the observations were plotted as is. All other statistics\nmodify the data before it reaches the geometry. We add as an example\n`stat_smooth()` which fits a smoother to the data. We override the default\ngeometry of `stat_smooth()` setting it to `geom_line()` with `geom = \"line\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg)) +\n  geom_point() +\n  stat_smooth(geom = \"line\", method = \"lm\", formula = y ~ x)\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-10-1.svg)\n:::\n:::\n\n\nThe correspondence between values in the data and values of an aesthetic is\ncontrolled by the corresponding _scale_. Here we replace the scale used by\ndefault (`scale_y_continuous()`) by `scale_y_log10()` so that the _y_ axis\nuses a logarithmic scale. Scales, as shown here only change the graphical\nrepresentation. The legends and tick labels still show the values before the\ntransformation, which in most cases makes the plot easy to read.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg)) +\n  geom_point() +\n  stat_smooth(geom = \"line\", method = \"lm\", formula = y ~ x) +\n  scale_y_log10()\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-11-1.svg)\n:::\n:::\n\n\n_Coordinates_ are applied after the statistics \"see\" the data, so changing the\nlimits with them is similar to zooming into a finalized plot based on all the\ndata. This is **very important** to remember when statistics are used as in a\nplot like this using scale limits to zoom in would result in the regression\nbeing fitted only to the data actually visible within the plotting area, while\nusing coordinate limits will ensure that the regression is fitted to the whole\ndata set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg)) +\n  geom_point() +\n  stat_smooth(geom = \"line\", method = \"lm\", formula = y ~ x) +\n  coord_cartesian(ylim = c(15, 25))\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-12-1.svg)\n:::\n:::\n\n\nA transformation applied through a coordinate affects the values after the\nstatistics has computed them, thus in this plot the linear regression is\nrepresented by a curve. This is in contrast to the example above with\n`scale_y_log10()` where the linear regression was fit to the `log10()`\ntransformed data and thus graphically represented by a straight line in spite of\nthe transformed _y_ scale.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg)) +\n  geom_point() +\n  stat_smooth(geom = \"line\", method = \"lm\", formula = y ~ x) +\n  coord_trans(y = \"log10\")\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-13-1.svg)\n:::\n:::\n\n\n_Themes_ are similar to style sheets, and they control the appearance and\nposition of only those graphical elements that are _not_ created by layer\nfunctions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg)) +\n  geom_point() +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-14-1.svg)\n:::\n:::\n\n\nMany elements in themes are defined hierarchically, and for example text sizes\nare by default set relative to a base size. Here we increase the size of text\nelements and change the base font family. However, the size of the points is not\naffected.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg)) +\n  geom_point() +\n  theme_classic(base_size = 20, base_family = \"serif\")\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-15-1.svg)\n:::\n:::\n\n\nWe can modify individual theme settings, instead or in addition to replacing\nthe theme as a whole.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg)) +\n  geom_point() +\n  theme(axis.title = element_text(face = \"bold\"),\n        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-16-1.svg)\n:::\n:::\n\n\nIn a plot for publication, axis and legend labels usually need to be clearer and\nmore elegant that simple variable names. `labs()` is a convenience function that\nmakes setting these texts straightforward. Embedding of _new line_ characters\n(`\\n`) withing the character strings is supported, and in some cases very\nuseful.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars,\n       aes(x = disp, y = mpg)) +\n  geom_point() +\n  labs(x = \"Engine displacement (cubic inches)\",\n       y = \"Fuel use efficiency\\n(miles per gallon)\",\n       title = \"Motor Trend Car Road Tests\",\n       subtitle = \"Source: 1974 Motor Trend US magazine\")\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-17-1.svg)\n:::\n:::\n\n\nFinally, as shown here, mappings can be to R expressions not just variables in\ndata. For example here we plot `mpg` (miles per gallon) vs. `disp / cyl` (the\ndisplacement of individual engine cylinders).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mtcars, \n       aes(x = disp / cyl, y = mpg, colour = factor(cyl))) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](ggplot2-introduction_files/figure-html/unnamed-chunk-18-1.svg)\n:::\n:::\n\n\n## The internals\n\nFor most users of 'ggplot2' and its extensions it is crucial to understand the grammar of graphics. The internals of `\"gg\"` objects can be ignored by most users, although a rough idea of how 'ggplot2' works can be useful when facing error messages and \"code that does not work\". It can be also useful in cases when modifying an existing `\"gg\"` object is the only available or easiest approach.\n\nAbove we have implicitly printed the plots into their graphical representation. Here we save the `\"gg\"` object into variable `p` and then explore the structure of the object, which reveals how the different components of the \"plot drawing recipe\" are stored. For example, one can see that \"actions\" are stored in the object as function definitions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np <- ggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point()\nsummary(p)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndata: manufacturer, model, displ, year, cyl, trans, drv, cty, hwy, fl,\n  class [234x11]\nmapping:  x = ~displ, y = ~hwy\nfaceting: <ggproto object: Class FacetNull, Facet, gg>\n    compute_layout: function\n    draw_back: function\n    draw_front: function\n    draw_labels: function\n    draw_panels: function\n    finish_data: function\n    init_scales: function\n    map_data: function\n    params: list\n    setup_data: function\n    setup_params: function\n    shrink: TRUE\n    train_scales: function\n    vars: function\n    super:  <ggproto object: Class FacetNull, Facet, gg>\n-----------------------------------\ngeom_point: na.rm = FALSE\nstat_identity: na.rm = FALSE\nposition_identity \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(p, max.level = 1, list.len = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nObject size: 29.3 kB\nList of 9\n $ data       : tibble [234 Ã— 11] (S3: tbl_df/tbl/data.frame)\n $ layers     :List of 1\n $ scales     :Classes 'ScalesList', 'ggproto', 'gg' <ggproto object: Class ScalesList, gg>\n    add: function\n    clone: function\n    find: function\n    get_scales: function\n    has_scale: function\n    input: function\n    n: function\n    non_position_scales: function\n    scales: list\n    super:  <ggproto object: Class ScalesList, gg> \n $ mapping    :List of 2\n  [list output truncated]\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(p$layers, max.level = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 1\n $ :Classes 'LayerInstance', 'Layer', 'ggproto', 'gg' <ggproto object: Class LayerInstance, Layer, gg>\n    aes_params: list\n    compute_aesthetics: function\n    compute_geom_1: function\n    compute_geom_2: function\n    compute_position: function\n    compute_statistic: function\n    computed_geom_params: NULL\n    computed_mapping: NULL\n    computed_stat_params: NULL\n    constructor: call\n    data: waiver\n    draw_geom: function\n    finish_statistics: function\n    geom: <ggproto object: Class GeomPoint, Geom, gg>\n        aesthetics: function\n        default_aes: uneval\n        draw_group: function\n        draw_key: function\n        draw_layer: function\n        draw_panel: function\n        extra_params: na.rm\n        handle_na: function\n        non_missing_aes: size shape colour\n        optional_aes: \n        parameters: function\n        rename_size: FALSE\n        required_aes: x y\n        setup_data: function\n        setup_params: function\n        use_defaults: function\n        super:  <ggproto object: Class Geom, gg>\n    geom_params: list\n    inherit.aes: TRUE\n    layer_data: function\n    map_statistic: function\n    mapping: NULL\n    position: <ggproto object: Class PositionIdentity, Position, gg>\n        compute_layer: function\n        compute_panel: function\n        required_aes: \n        setup_data: function\n        setup_params: function\n        super:  <ggproto object: Class Position, gg>\n    print: function\n    setup_layer: function\n    show.legend: NA\n    stat: <ggproto object: Class StatIdentity, Stat, gg>\n        aesthetics: function\n        compute_group: function\n        compute_layer: function\n        compute_panel: function\n        default_aes: uneval\n        dropped_aes: \n        extra_params: na.rm\n        finish_layer: function\n        non_missing_aes: \n        optional_aes: \n        parameters: function\n        required_aes: \n        retransform: TRUE\n        setup_data: function\n        setup_params: function\n        super:  <ggproto object: Class Stat, gg>\n    stat_params: list\n    super:  <ggproto object: Class Layer, gg> \n```\n:::\n:::\n\n\nPackage 'gginnards' makes it rather easy to modify `\"gg\"` objects. I find occasionally useful to alter the order of layers and to insert layers out-of-order in an exisiting `\"gg\"` object . Deleting those variables that have not been mapped to aesthetics from the data stored within an exisiting `\"gg\"` object can be sometimes simpler than constructing again the plot object with a subset of the data.\n\n::: callout-tip\nThis brief introduction only touched on the basic aspects of the grammar of graphics as implemented in R package 'ggplot2'. This is enough to get many different types of plots done successfully. In most cases, doing different types of plots requires one to find a suitable layer function. While in many cases default arguments to these functions will yield a usable plot, normally, studying the help page of a layer function will make clear its features and how to use them effectively. Thus, it is not necessary, and a waste of time, to try to become an expert across all possible types of plots. It is enough to understand how plots are assembled, and learn when the need arises, how to use individual layer functions.\n\nA good place to start looking for layer functions vailable in extension packages is to visiti the site [**ggplot2** extensions](https://exts.ggplot2.tidyverse.org/) and its [gallery](https://exts.ggplot2.tidyverse.org/gallery/), which is especially effective for those packages that are specialized and export a single or a few layer functions because the gallery displays a single example plot per package, and the list of extensions only very few examples per package. \n\n[Several of the pages](https://www.r4photobiology.info/galleries.html#category=Plotting%20examples) here listed under _galleries_ contain many examples of the use of the extensions to 'ggplot2' that I have published in packages 'ggpp', 'ggpmisc', 'gginnards' and 'ggspectra'.\n:::\n",
    "supporting": [
      "ggplot2-introduction_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}