{
  "hash": "222d47a1470e33f097b100d3c4783dea",
  "result": {
    "markdown": "---\ntitle: \"EDA with 'ggplot2'\"\nsubtitle: \"EDA = Exploratory Data Analysis\"\nauthor: \"Pedro J. Aphalo\"\ndate: 2022-05-24\ndate-modified: 2023-05-24\ncategories: [R, plotting]\nkeywords: [ggplot2 pkg, data visualization, dataviz]\nformat:\n  html:\n    code-fold: false\n    code-tools: true\n---\n\n\n::: callout-note\nTo see the source of this document click on \"</> CODE\" to the right of the\npage title. The page is written using [Quarto](https://quarto.org/) which is an enhanced version of [R Markdown](https://rmarkdown.rstudio.com/). The diagrams are created with [Mermaid](https://mermaid.js.org/), a language inspired by the simplicity of [Markdown](https://daringfireball.net/projects/markdown/syntax).\n:::\n\n::: callout-warning\nPackage ['ggplot2'](https://ggplot2.tidyverse.org/) has gained new features over its long life, and although few changes have been 'code brealking' you should be aware that the examples in this page have been tested with version (==3.4.2).\n:::\n\n## The stages of an experiment or survey\n\nExploratory data analysis, or EDA, can play two distinct roles, depending on the type of experiment or survey. \n\n1. Some research is based on testing of hypotheses set _a priori_ (before the the experiment is designed, or at least independently of the data collected in the current study), in which case EDA can be seen mainly as a quality control step asking whether there is anything unusual in the data that suggests problems during its collection or in the assumptions on which the design of the study was based.\n\n2. In other cases research aims at describing the system under study, in most cases, searching for meaningful relationships among variables. In such research EDA plays an additional role, it conveys information about the system under study. In such cases it is in most cases necessary to divide the data into a set used to generate testable hypotheses and a set used for validation (= testing of hypotheses).\n\n3. It is also possible to have as an aim to develop a purely empirical way of achieving a prediction. This is almost never the aim in basic scientific research because it aims at improving understanding. However this tends to be the norm when artificial intelligence and machine learning are used in practical applications.\n\n::: callout-tip\nEven if an experiment or survey is designed to test hypotheses set _a priori_, EDA can suggest new hypotheses to be tested in future experiments. Even if not testable with the same data, such hypotheses can be discussed during communication of results as something to be considered in future studies. However, in all cases it is imperative to clearly distinguish statements _supported by strong evidence_ from _new hypotheses suggested_ by the results of an experiment or survey.\n:::\n\nThe diagram in @fig-EDA-flowchart shows the position of EDA in the research process. Solid arrows show the most direct flow of information, while the dotted arrows show information-dependent connections that are also crucial. The dot \"arrow\" heads indicate that the connection imposes restrictions. For example the design of an experiment determines how the data collected can be analysed and interpreted. Decisions about what can be considered an outlier are informed by anomalies observed during the course of an experiment, thus the need to keep a written record of them. I have included _Tests of Hypotheses_ and _Model Selection_ as alternatives, but wording is rather unsatisfactory. The distinction is between testing hypotheses set _a priori_, versus searching for a model that describes the data well. In the first case we are interested in the _P_-values themselves, in the second case in the actual parameters estimates, such as the slope and intercept of a linear regression. In the first case, our _a priori_  hypotheses are hypotheses still about the values of parameter estimates from a fit of data to a model, so in both cases we rely on fitting one or more models to the observed data for our statistical analysis.\n\n\n```{mermaid}\n%%| label: fig-EDA-flowchart\n%%| fig-cap: A diagram showing the steps of a scientific study. This abstraction can be applied to empirical research, but with small changes (not shown) also to simulation studies.\n%%{init: {\"htmlLabels\": true} }%%\n\nflowchart TD\n  A(Design) --> B(Realization) <-.-> C[<strong>EDA</strong>] --> D(Model\\nSelection) --> E(Interpretation) --> F(Communication)\n  A -.-o D\n  B <--> H\n  A -.-o E\n  A -.-> H(Data collection) --> C\n  C --> G(Tests of\\nHypotheses) --> E\n  A -.-o G\n```\n\n\nIn most cases EDA relies heavily on the graphical display of data. It is however important to remember that different types of plots make it easy to visualize different aspects of a data set. In this page I show some examples using R and package 'ggplot2'.\n\n## Quality control\n\nBefore any plotting it is good to start by tabulating the data. `table()` is useful when we have categorical variables or factors, as we can use it to get counts of observations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(iris$Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n    setosa versicolor  virginica \n        50         50         50 \n```\n:::\n:::\n\n\nWith two factors we get a two-way table, and with additional factors, additional 2D tables. From this very simple table we can see that we have 50 observations per species. Had we had wrongly typed the species name in one cell we would get a different table.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(bad_iris$Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n   acetosa     setosa versicolor  virginica \n         1         49         50         50 \n```\n:::\n:::\n\nWe now know that there is an incorrectly encoded value, and we can find in which row it is.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(bad_iris$Species == \"acetosa\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\nWe can also replace it, if we are sure that this is a mistake. The code below will replace all instances of `\"acetosa\"` by `\"setosa\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbad_iris$Species[bad_iris$Species == \"acetosa\"] <- \"setosa\" # replaces the value\nbad_iris$Species <- factor(bad_iris$Species) # removes the level\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(bad_iris$Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n    setosa versicolor  virginica \n        50         50         50 \n```\n:::\n:::\n\n\nIn a case like this with 150 rows, I find this approach easier than editing a file. With thousands of observations all other viable options are based on scripts.\n\nThe organization of the data frame seems to be fine, so we may want to use `summary()` for a quick inspection.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   \n Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100  \n 1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300  \n Median :5.800   Median :3.000   Median :4.350   Median :1.300  \n Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199  \n 3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800  \n Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500  \n       Species  \n setosa    :50  \n versicolor:50  \n virginica :50  \n                \n                \n                \n```\n:::\n:::\n\n\nSummary is useful in that it provides a quick view of all the columns of the data frame and will also report the number of `NA` values in each colum.\n\nI am not showing an example, but when reading data from a text file (e.g., `.csv` file) if the decimal mark (`,` or `.`) is not recognized as such, numbers are read as text (`character` values) instead numbers (`numeric` values). It is enough that a single value in a whole column has the wrong decimal marker, for the whole column to be read as text. `summary()` can also help in such a case, as the summary for the affected column will not be numeric. \n\n::: callout-tip\n`NA` is an abbreviation for _Not Available_, it is used to indicate missing data. Observations that should have been available but were lost or are missing because of an \"accident\". They propagate in arithmetic operations. One or more missing values make the result that would have been obtained had the value(s) been available, also not available or unknown. In general, in R, removal of `NA` values is not the default, but can be explicitly requested.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNA + 10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\n`NaN` is an abbreviation for _Not a Number_, `NaN` values are generated by undefined arithmetic operations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(-1) # is undefined\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in log(-1): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NaN\n```\n:::\n\n```{.r .cell-code}\n1/0 # is a valid operation!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Inf\n```\n:::\n\n```{.r .cell-code}\n-5/0 # is a valid operation!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -Inf\n```\n:::\n\n```{.r .cell-code}\n1000 / Inf # is a valid operation!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n:::\n\n## Plots of single variables\n\nThe plots we will create today are for data exploration, not communication of results. If variable names are self explanatory as in the `iris` data set we do not need to change axis labels or change how plots look, except to ensure that the features of the data are clearly displayed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n```\n:::\n\n\n### Box plot\n\nA very popular type of plot for EDA are box plots (more descriptively, also called box and whiskers plots). John Tukey's most important and original contribution was on EDA methods, including box plots, not Tukey's HSD.\nIn the early 1970's easy of drawing and easy of computation were still crucial for method to be widely used, and this one of the goals in most of Tukey's work on EDA. In the `iris` data sets we have data from measurements of the size of different flower parts, petals and sepals. For each of them, width and length are available.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(iris, aes(x = Species, y = Petal.Length)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](ggplot2-EDA_files/figure-html/unnamed-chunk-12-1.svg)\n:::\n:::\n\n\n::: callout-caution\nThe advice is not to use box plots with small data sets, say with fewer than 10 to 15 observations per box plot (e.g., 50 observations for each of species in the figure above). The shape of the boxes and whiskers is quite reasonable with 50 observations per species, with very few observations the box plots are less informative than showing all the observations individually.\n:::\n\nAn enhancement to simple box plots is to show an approximate 95% confidence interval as a notch in the box plot. We can also make them narrower.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(iris, aes(x = Species, y = Petal.Length)) +\n  geom_boxplot(notch = TRUE, width = 0.3)\n```\n\n::: {.cell-output-display}\n![](ggplot2-EDA_files/figure-html/unnamed-chunk-13-1.svg)\n:::\n:::\n\n### Dot plot\n\nFor exploration one would think that plotting all observations would be ideal, but how can we ensure that all observations are visible rather than occluded by other observations. We can use transparency, but this works well only with few overlaps, so works well in those situations when we have too few observations for a more complex visual like a boxplot or density plots. In the example I use `alpha = 0.25` meaning that a point is 1/4 opaque and 3/4 transparent. For a point to look black, four or more observations have to overlap.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(iris, aes(x = Species, y = Petal.Length)) +\n  geom_point(alpha = 0.25)\n```\n\n::: {.cell-output-display}\n![](ggplot2-EDA_files/figure-html/unnamed-chunk-14-1.svg)\n:::\n:::\n\n\nAnother approach is randomly displace points along the _x_ axis to avoid overlaps.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(iris, aes(x = Species, y = Petal.Length)) +\n  geom_point(position = position_jitter(width = 0.25))\n```\n\n::: {.cell-output-display}\n![](ggplot2-EDA_files/figure-html/unnamed-chunk-15-1.svg)\n:::\n:::\n\n\n### Violin plot\n\nSurely we can do better than this with modern computers! Box plots aim at describing the distribution of observations based on the median, quartiles and range, and possible \"outliers\". Violin plots are like box plots but describe the density distribution with a fitted curve.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(iris, aes(x = Species, y = Petal.Length)) +\n  geom_violin()\n```\n\n::: {.cell-output-display}\n![](ggplot2-EDA_files/figure-html/unnamed-chunk-16-1.svg)\n:::\n:::\n\n\n### Beeswarm plot\n\nA final alternative is to combine violin plots with showing the observations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggbeeswarm)\nggplot(iris, aes(x = Species, y = Petal.Length)) +\n  geom_quasirandom(width = 0.25)\n```\n\n::: {.cell-output-display}\n![](ggplot2-EDA_files/figure-html/unnamed-chunk-17-1.svg)\n:::\n:::\n\n\nThese are some of the common variations around the theme of boxplots, or more accurately plots that give information not only on the _central tendency_ and _spread_ of the data but also on the _shape_ the empirical density distribution. This approach differs from the approach of showing means and standard errors, or confidence intervals, that implicitly assume that the data have been sampled from a population that follows a Normal distribution.\n\n### What do these plots tell us\n\nIn the case of variable `Petal.Length` from the `iris` data set it is clear that the spread of the values is less for _I. setosa_ than for the other two species. The distributions are rather symmetrical around the median, and no unusual or unexpected observations, or _outliers_ can be seen. What is considered an outliers in box plots and plotted individually should be taken with a grain of salt, as it can be affected by the number of observations plotted. For example, I would not worry about the highlighted \"outliers\" in the data for _I. setosa_. In this case, what would need to be considered for a data analysis is the heterosedasticity or differences in spread or variance.\n\nWe would make similar plots for other variables and explore their properties.\n\n### What type of plot to use?\n\nWe are exploring the data, so essentially we can use what works best for us and our data. However, one key consideration is the number of observations. If we have many hundreds of observations, then violin plots are the best option, as anything else would become cluttered. The _beeswarm_ plot is useful with several tens of observations up to a couple of hundreds if one adjusts the size of the points and the width of the swarm. When using points to represent individual observations, the upper limit depends on the spread of the data compared to the plotting area (we can see this effect for _Iris setosa_ compared to the other species). I would avoid jitter, as I personally find it difficult to visualize the density in such plots, although it is used quite frequently.\n\n## Exploring relationships\n\nIn the `iris` data set we could be interested in the relationships among the measured variables. Even if when plotted individually the data for each measured variable do not show anything unusual, a more subtle kind of outlier would be an unexpected relationship between petal length and width.\n\n### Scatter plot\n\nA scatter plot is the simplest and usually first approach to try. As now there is variation both along _x_ and _y_ axes, overlaps are less likely for the same number of observation than in the case of dot plots (it is anyway important to use transparency to make sure overlaps do not remain unnoticed). We have three species, so I would start by using separate panels. We are not much interested in the actual results or interpretation, we are mainly focusing on quality of the data and properties that will affect how to analyse it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(iris, aes(x = Petal.Width, y = Petal.Length)) +\n  geom_point(alpha = 0.25) +\n  facet_wrap(facets = vars(Species), scales = \"free\")\n```\n\n::: {.cell-output-display}\n![](ggplot2-EDA_files/figure-html/unnamed-chunk-18-1.svg)\n:::\n:::\n\n\nWe can two interesting things: 1) the real world width and length are continuous variables, but measurements have been done to the nearest 0.1 units, and 2) because of this there are quite many overlapping observations, specially for _I. setosa_ because of the smaller spread of the values: we see only 20 points but we have 50 observations. This is a rather uncommon situation, but as earlier we can use jitter, but now along both _x_ and _y_. Using as maximum displacement half the resolution of the measured quantities gives a more reasonable set of plots. Some partial overlaps remain, but these are clearly visible.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(iris, aes(x = Petal.Width, y = Petal.Length)) +\n  geom_point(alpha = 0.25, position = position_jitter(width = 0.05, height = 0.05)) +\n  facet_wrap(facets = vars(Species), scales = \"free\")\n```\n\n::: {.cell-output-display}\n![](ggplot2-EDA_files/figure-html/unnamed-chunk-19-1.svg)\n:::\n:::\n\n\nNow that we have dealt with the overlaps, we can use a common scale, to be able to compare the species.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(iris, aes(x = Petal.Width, y = Petal.Length)) +\n  geom_point(alpha = 0.25, position = position_jitter(width = 0.05, height = 0.05)) +\n  facet_wrap(facets = vars(Species)) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](ggplot2-EDA_files/figure-html/unnamed-chunk-20-1.svg)\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(iris, aes(x = Petal.Width, y = Petal.Length)) +\n  geom_point(alpha = 0.25, position = position_jitter(width = 0.05, height = 0.05)) +\n  facet_wrap(facets = vars(Species)) +\n  scale_x_log10() +\n  scale_y_log10() +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](ggplot2-EDA_files/figure-html/unnamed-chunk-21-1.svg)\n:::\n:::\n\n\nWith many observations we face again the problem of overlaps, and the best option is again to describe the 2D empirical distribution of the data. As with violin plots outliers can disappear from our view. One approach is to add the outliers as individual observations to a density plot. We start with a plain density plot. Package 'ggplot2' provides `stat_density2D()`, however, `stat_hdr()` presents the areas in a more useful way. For this particular data set `stat_density2D()`, using default arguments fails. I use the `iris` data set, although this approach is specially well suited to large data sets (I have used it with over 500000 observations per plot).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggdensity)\nggplot(iris, aes(x = Petal.Width, y = Petal.Length)) +\n  stat_hdr() +\n  expand_limits(x = c(-0.5, 3), y = c(0, 7.5)) +\n  facet_wrap(facets = vars(Species)) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](ggplot2-EDA_files/figure-html/unnamed-chunk-22-1.svg)\n:::\n:::\n\n\nTo understand the relationship between the density estimates and the observations, we can add the observations as semitransparent points.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggdensity)\nggplot(iris, aes(x = Petal.Width, y = Petal.Length)) +\n  stat_hdr() +\n  geom_point(colour =\"yellow\",\n             alpha = 0.5, \n             position = position_jitter(width = 0.05, height = 0.05)) +\n  expand_limits(x = c(-0.5, 3), y = c(0, 7.5)) +\n  facet_wrap(facets = vars(Species)) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](ggplot2-EDA_files/figure-html/unnamed-chunk-23-1.svg)\n:::\n:::\n\n\n## Errors are not always obvious\n\nTo end I will freely tell from memory what is I think, I wonderful demostration, that plotting can show patterns that otherwise remain hidden. More so, different types of plots can reveal diferent features, including problems. Data set `barley` included in package 'lattice' includes data for yeild in bushels per acre of 10 barley cultivars in Minnesota field trials at six sites on years 1931 and 1932. The question was revisited most recently by Wright (Wright, Kevin (2013). Revisiting Immer's Barley Data. _The American Statistician_, **67**(3), 129–133.)\n\nThe story goes like this, there is what looks like an error in the data coding, that was discovered only in 1993, or nearly 60 years after the first publication of the data. The first report about the problem was by Cleveland (1993), who popularized \"trellis\" plots, which are equivalent to what are called facets in 'ggplot2'. Most astonishing is that the data had been used in the interim in examples in statistics books, with the error unnoticed. This just, highlights the need to be careful about EDA, and not assuming that it is very easy, that errors will easily be in sight in the first plot done. The time spent checking the data is very well spent, as it avoids difficulties at all later stages and protects us from reaching wrong conclusions.\n\nThe plots below are what I would have used nowadays without consulting the publications by Cleveland and collaborators (https://hci.stanford.edu/courses/cs448b/papers/becker-trellis-jcgs.pdf) and I first became aware of in the early 2000's.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lattice)\nggplot(barley, aes(x = year, y = yield)) +\n  geom_col(width = 0.67) +\n  expand_limits(y = 0) +\n  facet_grid(rows = vars(variety), cols = vars(site))\n```\n\n::: {.cell-output-display}\n![](ggplot2-EDA_files/figure-html/unnamed-chunk-24-1.svg)\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lattice)\nggplot(barley, aes(x = year, y = yield)) +\n  stat_summary(fun = median, geom = \"col\", \n               width = 0.67) +\n  expand_limits(y = 0) +\n  facet_grid(cols = vars(site))\n```\n\n::: {.cell-output-display}\n![](ggplot2-EDA_files/figure-html/unnamed-chunk-25-1.svg)\n:::\n:::\n\n\nWe can make the difference even more visible by better distinguishing the years. This plot is more refined graphically than the usual EDA plots, but tries to demonstrate that the selection of graphical representation affects affects what patterns we recognize easily.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lattice)\nggplot(barley, aes(x = year, y = yield, fill = year)) +\n  stat_summary(fun = median, geom = \"col\", \n               colour = \"black\", width = 0.67) +\n  expand_limits(y = 0) +\n  scale_fill_grey() +\n  facet_grid(cols = vars(site)) +\n  theme_bw() +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](ggplot2-EDA_files/figure-html/unnamed-chunk-26-1.svg)\n:::\n:::\n\n\nErrors become obvious when we discover them, but before we plot the data in a revealing way they are not obvious at all! In this case, it is difficult after some many years to get to the root of the problem. We may guess a miscoding of years for the data from Morris, but as far as I know, this is just a hypothesis. Had the odd results been noticed by those collecting the data, and either corrected or described as being a real feature when they reported them in a publication, we could be sure of what had happened.\n",
    "supporting": [
      "ggplot2-EDA_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}