{
  "hash": "90c1f027615a4ac4edfc691892dabe48",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Is this a polynomial?\"\nsubtitle: \"Computing on the R langauge\"\nauthor: \"Pedro J. Aphalo\"\ndate: 2024-05-16\ndate-modified: 2024-05-22\ncategories: [R, plotting]\nkeywords: [ggpmisc pkg, R programming, annotations]\ncode-fold: false\ncode-tools: true\n---\n\n\n## The problem\n\nTwo statistics from package 'ggpmisc' could produce bad return values if the\nmodel formula passed by users as argument did not match the expectations. The\nproblem was that any valid model formula accepted by `lm()` or `rlm()` would be\nsilently accepted as input but only some formulations would result in valid\nequation labels added to plots. Although the statistics expect what to me feels\nlike the \"normal\" way of writing a polynomial and this is clearly described in\nthe documentation, some users had different expectations. So, in spite of the\nexamples in the documentation an issue was raised for a bug. Of course the lack\nof a proper test was a bug, but not as the user thought, one affecting input\nthat was deemed correct by design. Of course, functions like these should check\nthat user-provided input is valid and will result in correct output.\n\nWhy I did not implement a check earlier? It seemed to me at first that\nimplementing code for such a test was an extremely difficult task. However, one\nof the strong points of the R language is that language objects like model\nformulas can be manipulated and converted like almost any other object in R.\nMaking the story short, it was fairly easy to write an ad-hoc first version of a function to\nvalidate model functions as representing a polynomial. It took a couple of hours\nof design, coding, testing, revision, and trying to imagine all the different\nways in which polynomials can be described in model functions, as well as\nimagining model functions that are similar to polynomials but not true\npolynomials. The first version, and the second partial rewrite were not perfect,\nthey produced both false positive and false negative results occasionally. After\nadding a bunch of unit tests and further changes to the code, the function seems\nto now work fairly well. It will still mark as bad some possibly borderline\ncases.\n\nThe aim was not simply to detect model formulas describing a polynomial from\nothers. The aim was to detect model formulas describing polynomials that would\nresult in valid equation labels from others. Now using this test, the statistics\nreturn NA and issue a warning when they cannot handle the model described by\nthe model formula. In this cases, the user can still assemble the equation\nlabel within a call to `aes()` as the numeric values of the coefficirnt \nestimates is still returned. \n\nGiven how the two statistics work, polynomials have to have the\nterms in order of increasing powers, and they can have or not a constant\n(y-intercept) term. In addition terms in a model formula, containing a bare `^`\noperator are only powers of the explanatory variable if enclosed in an _as.is_\ncall (`I()`). Power transformations are currently not accepted if applied to a \nsingle term.\n\n::: callout-note\n\nDoes this function give false positives and false negatives? Likely, but\nhopefully I haven't missed any frequently used case. Time and further testing\nwill tell. _Please, do raise \n[an issue](https://github.com/aphalo/ggpmisc/issues) if you discover a failure._\n\nMeanwhile, the two statistics, `stat_poly_eq()` and `stat_quant_eq()`, now issue\na warning when passed model formulas that fail this new test and set `eq.label`\nto `NA` in the returned data frame, the `data` seen by the downstream geometry.\n\n:::\n\nThe function, `check_poly_formula()` has an on-line version of [its help page](https://docs.r4photobiology.info/ggpmisc/reference/check_poly_formula.html),\nwith some code examples.\n\nAnd here is the definition of `check_poly_formula()` as of 2024-05-22:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncheck_poly_formula <-\n  function(formula,\n           x.name = \"x\",\n           warning.text = \"'formula' not an increasing polynomial: 'eq.label' is NA!\") {\n  rhs <- as.character(formula)[3]\n  rhs.terms <- unlist(strsplit(x = rhs, split = c(\"+\", \"*\"), fixed = TRUE))\n  num.terms <- length(rhs.terms)\n  x.terms <- grepl(x.name, rhs.terms)\n  poly.in.terms <- grepl(\"poly *\\\\(\", as.character(formula)[3L])\n  power.terms  <- grepl(\"\\\\^ *\", rhs.terms)\n  raw.terms  <- grepl(\"raw *=\", rhs.terms)\n  as.is.terms <- grepl(\"I *\\\\(\", rhs.terms)\n\n  if (num.terms > 1L && poly.in.terms && sum(power.terms) != 0L) {\n    stop(\"Both 'poly()' and power (^) terms in model formula.\")\n  }\n  if (num.terms > 1L && !all(which(power.terms) %in% which(as.is.terms))) {\n    warning(\"Power (^) terms in model formula of a polynomial need to be protected by 'I()'.\")\n    return(FALSE)\n  }\n  if (poly.in.terms && !sum(raw.terms)) {\n    warning(\"'poly()' in model formula has to be passed 'raw = TRUE'\")\n  }\n  if (sum(x.terms) == 0L || poly.in.terms && num.terms == 1L) {\n    polynomial <- TRUE\n    increasing <- TRUE\n  } else if (sum(power.terms) < 1L ||\n             sum(power.terms) == num.terms - 1L &&\n             sum(x.terms) == num.terms ||\n             sum(power.terms) == num.terms - 2L &&\n             sum(x.terms) == num.terms - 1L) {\n    polynomial <- TRUE\n    if (sum(x.terms) == 1L || min(which(power.terms)) %in% 2L:3L) {\n      powers <- as.numeric(gsub(\".*\\\\^([0-9]+).*\", \"\\\\1\", rhs.terms[power.terms]))\n      increasing <- length(powers) <= 1L ||\n        !is.unsorted(powers, strictly = TRUE) &&\n        max(powers) == length(powers) + 1 # no missing terms\n    } else {\n      increasing <- FALSE\n    }\n  } else {\n    polynomial = FALSE\n  }\n  if (!polynomial || !increasing) {\n    if (length(warning.text)) {\n      warning(warning.text)\n    }\n    FALSE\n  } else {\n    TRUE\n  }\n}\n```\n:::\n\n\n\nAm I still missing something? Can the code be really this simple? (well, no longer so simple...)\n\nSome examples follow.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggpmisc)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: ggpp\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: ggplot2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRegistered S3 methods overwritten by 'ggpp':\n  method                  from   \n  heightDetails.titleGrob ggplot2\n  widthDetails.titleGrob  ggplot2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'ggpp'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:ggplot2':\n\n    annotate\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ x^3)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in check_poly_formula(y ~ x^3): 'formula' not an increasing polynomial:\n'eq.label' is NA!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ poly(x, 2))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in check_poly_formula(y ~ poly(x, 2)): 'poly()' in model formula has to\nbe passed 'raw = TRUE'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ x + 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ x - 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ x + 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ x + I(x^2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ 1 + x + I(x^2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ I(x^2) + x)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in check_poly_formula(y ~ I(x^2) + x): 'formula' not an increasing\npolynomial: 'eq.label' is NA!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ x + I(x^2) + I(x^3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ I(x^2) + I(x^3))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in check_poly_formula(y ~ I(x^2) + I(x^3)): 'formula' not an increasing\npolynomial: 'eq.label' is NA!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ x + I(x^3) + I(x^2))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in check_poly_formula(y ~ x + I(x^3) + I(x^2)): 'formula' not an\nincreasing polynomial: 'eq.label' is NA!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}