{
  "hash": "135212e677d212d5412d67a6e7acd443",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Is this a polynomial?\"\nsubtitle: \"Computing on the R langauge\"\nauthor: \"Pedro J. Aphalo\"\ndate: 2024-05-16\ndate-modified: 2024-05-16\ncategories: [R, plotting]\nkeywords: [ggpmisc pkg, R programming]\ncode-fold: false\ncode-tools: true\n---\n\n\n## The problem\n\nTwo statistics from package 'ggpmisc' could produce bad return values if the\nmodel formula passed by users as argument did not match the expectations. The\nproblem was that any valid model formula accepted by `lm()` or `rlm()` would\nbe silently accepted as input but only some formulations would result in valid\nequation labels added to plots. Although the statistics expect what to me\nfeels like the \"normal\" way of writing a polynomial, some users had different\nexpectations. So, in spite of the examples in the documentation an issue was\nraised for a bug. Of course the lack of a proper test was a bug, but not as\nthe user thought, one affecting input that was deemed correct by design. Of\ncourse, functions like these should check that user-provided input\nis valid and will result in correct output.\n\nWhy I did not implement a check earlier? It seemed to me at first that\nimplementing code for such a test was an extremely difficult task. However, one\nof the strong points of the R language is that langauge objects like model\nformulas can be manipulated and converted like almost any other object in R.\nMaking the story short, it was fairly easy to write an ad-hoc function to\nvalidate model functions as representing a polynomial. It took a couple of hours\nof design, coding, testing, revision, and trying to imagine all the different\nways in which polynomials can be described in model functions, as well as\nimagining model functions that are similar to polynomials but not true\npolynomials. Given how the two statistics work, polynomials have to have the\nterms in order of increasing power, and they can have or not a constant\n(y-intercept) term. In addition terms in a model formula, containing a bare `^`\noperator are only powers of the explanatory variable if inclosed in an _as.is_\ncall (`I()`). Power transformations are also acceptable if applied to a single\nterm.\n\n::: callout-note\n\nDoes this function give false positives and false negatives? Possibly, time and\nfurther testing will tell. Meanwhile, the two statistics now issue a warning when\npassed model formulas that fail this new test.\n\n:::\n\nThe function, `check_poly_formula()` has an on-line version of [its help page](https://docs.r4photobiology.info/ggpmisc/reference/check_poly_formula.html),\nwith some code examples.\n\nAnd here is the code as of 2024-05-16:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncheck_poly_formula <-\n  function(formula,\n           x.name = \"x\",\n           warning.text = \"'formula' is not an increasing polynomial: expect bad/no 'eq.label'!\") {\n  term.labels <- attr(terms(formula), \"term.labels\")\n  num.terms <- length(term.labels)\n  x.terms <- grepl(x.name, term.labels)\n  poly.in.terms <- grepl(\"poly *\\\\(\", as.character(formula)[3L])\n  power.terms  <- grepl(\"\\\\^ *\", term.labels)\n  as.is.terms <- grepl(\"I *\\\\(\", term.labels)\n\n  if (num.terms > 1L && poly.in.terms && sum(power.terms) != 0L) {\n    stop(\"Both 'poly()' and power (^) terms in model formula.\")\n  }\n  if (num.terms > 1L && !all(power.terms == as.is.terms)) {\n    stop(\"Power (^) terms in model formula need to be protected by 'I()'.\")\n  }\n  if (num.terms == 0L || poly.in.terms && num.terms == 1L) {\n    polynomial <- TRUE\n    increasing <- TRUE\n  } else if (sum(power.terms) <= 1L ||\n             sum(power.terms) == num.terms - 1L &&\n             sum(x.terms) == num.terms) {\n    polynomial <- TRUE\n    if (sum(x.terms) == 1L || min(which(power.terms)) == 2L) {\n      powers <- as.numeric(gsub(\".*\\\\^([0-9]+).*\", \"\\\\1\", term.labels[power.terms]))\n      increasing <- length(powers) <= 1L ||\n        !is.unsorted(powers, strictly = TRUE) &&\n        max(powers) == length(powers) + 1 # no missing terms\n    } else {\n      increasing <- FALSE\n    }\n  } else {\n    polynomial = FALSE\n  }\n  if (!polynomial || !increasing) {\n    if (length(warning.text)) {\n      warning(warning.text)\n    }\n    FALSE\n  } else {\n    TRUE\n  }\n}\n```\n:::\n\n\n\nAm I still missing something? Can the code be really this simple?\n\nSome examples follow.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggpmisc)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: ggpp\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: ggplot2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRegistered S3 methods overwritten by 'ggpp':\n  method                  from   \n  heightDetails.titleGrob ggplot2\n  widthDetails.titleGrob  ggplot2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'ggpp'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:ggplot2':\n\n    annotate\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ x^3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ poly(x, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ x + 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ x - 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ x + 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ x + I(x^2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ I(x^2) + x)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in check_poly_formula(y ~ I(x^2) + x): 'formula' is not an increasing\npolynomial: expect bad/no 'eq.label'!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ x + I(x^2) + I(x^3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ I(x^2) + I(x^3))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in check_poly_formula(y ~ I(x^2) + I(x^3)): 'formula' is not an\nincreasing polynomial: expect bad/no 'eq.label'!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ncheck_poly_formula(y ~ x + I(x^3) + I(x^2))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in check_poly_formula(y ~ x + I(x^3) + I(x^2)): 'formula' is not an\nincreasing polynomial: expect bad/no 'eq.label'!\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}