{
  "hash": "6de83febef505b5e0dfa70f75532d55a",
  "result": {
    "markdown": "---\ntitle: \"ggplot fitted-model equations with 'ggpmisc'\"\nsubtitle: \"Polynomials, major axis, quantile and non-linear regression\"\nauthor: \"Pedro J. Aphalo\"\ndate: \"2023-02-27\"\nkeywords: [ggplot2 pkg, ggpp pkg, ggpmisc pkg, data labels, plot annotations, model equations]\ncategories: [Plotting examples]\neditor: \n  markdown: \n    wrap: 72\nformat:\n  html: \n    code-link: true\n    code-tools: true\n---\n\n\n## Introduction\n\nHere you will find examples of ggplots with insets. The insets have been\nadded to the plots with geometries defined in package 'ggpp' and\nstatistics from package 'ggpmisc' both available at CRAN. The\ndocumentation of [package 'ggpp'](https://docs.r4photobiology.info/ggpp)\nand of [package 'ggpmisc'](https://docs.r4photobiology.info/ggpmisc) is\navailable on-line.\n\n::: callout-tip\nIn this page code chunks are \"folded\" so as to decrease the clutter when\nsearching for examples. Above each plot you will find a small triangle\nfollowed by \"Code\". Clicking on the triangle \"unfolds\" the code chunk\nmaking visible the R code used to produce the plot. Except for the\nloading of packages shown in section **Preliminaries** code examples are\nin most cases self contained. When they are not, this is indicated by a\ncomment.\n\nAll \"words\" defined in base R or in extension packages are linked to the\ncorresponding HTML-rendered help pages.\n\nThe code in the chunks can be copied by clicking on the top right\ncorner, where an icon appears when the mouse cursor hovers over the code\nlisting.\n:::\n\nFor simplicity, whenever possible I use base R functions instead of\ncontributed R packages. For those packages used only in specific\nexamples I use colon notation to indicate the 'package'.\n\n::: callout-important\nOne needs to always check that annotations do not occlude anything\nsignificant, such as observations in the base plot. This needs special\ncare when using annotations together with batch plotting. Either ensure\nthat the scale limits of the base plot are expanded to avoid overlap or\nthat the layer with the equations is the lowest one, i.e., added to the\nplot first.\n:::\n\n## Data labels and plot annotations\n\nData labels add textual information directly related to individual data\npoints (shown as glyphs). Text position in this case is dependent on the\nscales used to represent data points. Text is usually displaced so that\nit does not occlude the glyph representing the data point and when the\nlink to the data point is unclear, this link is signaled with a line\nsegment or arrow. Data labels are distinct from annotations in that they\ncontribute directly to the representation of data on a plot or map.\n\nAnnotations differ from data labels, in that their position is decoupled\nfrom their meaning. Insets can be thought as larger, but still\nself-contained annotations. In most cases the reading of inset tables\nand plots depends only weakly on the plot or map in which they are\nincluded.\n\nIn the case of annotations and insets the designer of a data\nvisualization has the freedom to locate them anywhere, as long as they\ndo not occlude features used to describe data. I will use the term\nannotation irrespective if the \"labels\" are textual or graphical.\n\nThe equations showing parameter estimates from models fit to data are\nnormally displayed as annotations. However, it is also possible to\nconsider them data labels \"connected\" to individual curves representing\nthe corresponding model fits.\n\n## Annotations showing parameters estimates\n\nFitted model equations and other related estimates can be useful in\nplots as they ensure that graphical representation as a curve and\nnumerical values for parameters that cannot be read from the curve\nitself are displayed as text on the same plot.\n\n::: callout-note\nWhen adding annotations one should be aware that they add clutter to a\nplot, and clutter can make it difficult to see the patterns of interest\nin the data represented as points or curves.\n\nSo, as usual, less is more, include those annotations that are relevant\nto the message conveyed by a plot and nothing more.\n:::\n\nFully automating the construction of fitted model equations is far from\ntrivial for the general case, so I have implemented automation for\nspecific types of models: polynomials fitted by OLS as linear models,\npolynomials fitted by quantile regression and major-axis regression\nfits. They are currently available as pairs of statistics with\nconsistent interfaces, with each pair consisting in a curve-plotting\nstatistics and an annotations statistics.\n\nAs shown below other model formulas can be rather easily assembled and\nadded as annotations if one is familar with R's expressions as used for\n`plotmath`.\n\n## Preliminaries\n\nThe code used is shown on-demand above each plot and can be copied. We\nfirst load the packages we will use.\n\nWhen package 'ggpmisc' is loaded and attached, packages 'ggpp' and\n'ggplot2' are also attached. The only function from 'ggplot2' that is\nredefined by 'ggpp' is `annotate()`, which remains backwards compatible\nwith 'ggplot2'.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(ggpmisc)\nlibrary(ggrepel)\nlibrary(dplyr)\n```\n:::\n\n\n## Linear correlation\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(94321)\nx <- (1:100) / 10\nyA <- x + rnorm(length(x), sd = 2)\nyB <- x + rnorm(length(x), sd = 8)\nmy.data <- data.frame(x = rep(x, 2),\n                      y = c(yA, yB),\n                      group = rep(c(\"A\", \"B\"), rep(length(x), 2L)))\n```\n:::\n\n\nThe examples in this section make use of `stat_correlation()` from package\n'ggpmisc'. Please, see its [help page](https://docs.r4photobiology.info/ggpmisc/reference/stat_correlation.html)\nfor details.\n\nPearson correlation.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(subset(my.data, group == \"A\"), \n       aes(x, y)) +\n  geom_point() +\n  stat_correlation()\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-4-1.svg){fig-align='center'}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(subset(my.data, group == \"A\"), \n       aes(x, y)) +\n  geom_point() +\n  stat_correlation(small.r = TRUE)\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-5-1.svg){fig-align='center'}\n:::\n:::\n\n\nSpearman correlation.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(subset(my.data, group == \"A\"), \n       aes(x, y)) +\n  geom_point() +\n  stat_correlation(method = \"spearman\")\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-6-1.svg){fig-align='center'}\n:::\n:::\n\n\nKendall correlation.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(subset(my.data, group == \"A\"), \n       aes(x, y)) +\n  geom_point() +\n  stat_correlation(method = \"kendall\")\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-7-1.svg){fig-align='center'}\n:::\n:::\n\n\nSelect which labels to show in plot.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(subset(my.data, group == \"A\"), aes(x, y)) +\n  geom_point() +\n  stat_correlation(mapping = use_label(c(\"R\", \"P\", \"n\")),\n                   method = \"kendall\")\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-8-1.svg){fig-align='center'}\n:::\n:::\n\n\nSelect which labels to show in plot.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(subset(my.data, group == \"A\"), aes(x, y)) +\n  geom_point() +\n  stat_correlation(mapping = use_label(c(\"R\", \"t\", \"P\", \"n\")))\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-9-1.svg){fig-align='center'}\n:::\n:::\n\n\nConfidence interval for R.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(subset(my.data, group == \"A\"), aes(x, y)) +\n  geom_point() +\n  stat_correlation(mapping = use_label(c(\"R\", \"R.confint\")),\n                   r.conf.level = 0.99)\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-10-1.svg){fig-align='center'}\n:::\n:::\n\n\nGrouping supported.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(my.data, aes(x, y, color = group)) +\n  geom_point() +\n  stat_correlation()\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-11-1.svg){fig-align='center'}\n:::\n:::\n\n\nFacets supported.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(my.data, aes(x, y)) +\n  geom_point() +\n  stat_correlation(npcx = \"right\", npcy = \"bottom\") +\n  facet_wrap(~group)\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-12-1.svg){fig-align='center'}\n:::\n:::\n\n\nHighlighting based on estimates, here estimated *R* but it is possible\nto use other estimates like *P*-value.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(my.data, aes(x, y)) +\n  geom_point() +\n  stat_correlation(mapping = \n                     aes(color = ifelse(after_stat(cor) > 0.5,\n                                        \"red\", \"black\"))) +\n  scale_color_identity() +\n  facet_wrap(~group)\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-13-1.svg){fig-align='center'}\n:::\n:::\n\n\n### Alternatives\n\n::: callout-tip\nPackage 'ggpubr' provides alternative approaches to corelation testing\nand reporting.\n:::\n\n## Polynomials\n\nPolynomials as linear models, but many other linear models exist. The most\ncommon case is linear regression. They are very frequently used, and in the\ncase of linear regression the role of parameters can be easily recognized.\n\nThe examples in this section make use of `stat_poly_line()` and `stat_poly_eq()`\nfrom package 'ggpmisc'. Please, see the [help page for `stat_poly_line()`](https://docs.r4photobiology.info/ggpmisc/reference/stat_poly_line.html)\nand the [help page for `stat_poly_eq()`](https://docs.r4photobiology.info/ggpmisc/reference/stat_poly_eq.html) for details.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(4321)\n# generate artificial data\nx <- 1:100\ny <- (x + x^2 + x^3) + rnorm(length(x), mean = 0, sd = mean(x^3) / 4)\ny <- y / max(y)\nmy.data <- data.frame(x, \n                      y, \n                      group = c(\"A\", \"B\"), \n                      y2 = y * c(1, 2) + c(0, 0.2),\n                      block = c(\"a\", \"a\", \"b\", \"b\"),\n                      wt = sqrt(x))\n```\n:::\n\n\n$R^2$ is the default label, as it is always available.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(my.data, aes(x, y)) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(formula = formula)\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-15-1.svg){fig-align='center'}\n:::\n:::\n\n\nFitted model equation, available for polynomials with no missing terms.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(my.data, aes(x, y)) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(mapping = use_label(\"eq\"), formula = formula)\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-16-1.svg){fig-align='center'}\n:::\n:::\n\n\n$R_\\mathrm{adj}^2$ and *P*-value added separately.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(my.data, aes(x, y)) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(mapping = use_label(\"adj.R2\"), formula = formula) +\n  stat_poly_eq(mapping = use_label(\"P\"), label.x = \"right\", label.y = \"bottom\", size = 3,\n               formula = formula)\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-17-1.svg){fig-align='center'}\n:::\n:::\n\n\nFitted model equation and $R_\\mathrm{adj}^2$.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(my.data, aes(x, y)) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(mapping = use_label(c(\"eq\", \"adj.R2\"), sep = \"~~italic(\\\"with\\\")~~\"),\n               formula = formula)\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-18-1.svg){fig-align='center'}\n:::\n:::\n\n\nEquation with no left-hand-side (lhs).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(my.data, aes(x, y)) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(mapping = use_label(\"eq\"),\n               eq.with.lhs = FALSE,\n               formula = formula)\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-19-1.svg){fig-align='center'}\n:::\n:::\n\n\nVariable names in the equation set to be meaningful.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(my.data, aes(x, y)) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(mapping = use_label(c(\"eq\", \"R2\")),\n               eq.with.lhs = \"italic(h)~`=`~\",\n               eq.x.rhs = \"~italic(z)\",\n               formula = formula) +\n  labs(x = expression(italic(z)), y = expression(italic(h)))\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-20-1.svg){fig-align='center'}\n:::\n:::\n\n\nEven Greek charactes and maths can be incorporated when needed.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 2, raw = TRUE)\nggplot(my.data, aes(x, log10(y + 1e6))) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(mapping = use_label(\"eq\"),\n               eq.with.lhs = \"plain(log)[10](italic(delta)+10^6)~`=`~\",\n               eq.x.rhs = \"~Omega\",\n               formula = formula) +\n  labs(y = expression(plain(log)[10](italic(delta)+10^6)), \n       x = expression(Omega))\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-21-1.svg){fig-align='center'}\n:::\n:::\n\n\nThe examples shown above also work with groups.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(my.data, aes(x, y2, colour = group)) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(aes(label = after_stat(eq.label)), \n               formula = formula, \n               vstep = 0.08) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-22-1.svg){fig-align='center'}\n:::\n:::\n\n\nUsing colours to indicate the groups to which equations correspond is\nnot always best. Here we use labels to the left of each equation.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(my.data, aes(x, y2, linetype = group, grp.label = group)) +\n  geom_point() +\n  stat_poly_line(formula = formula, color = \"black\") +\n  stat_poly_eq(aes(label = after_stat(paste(\"bold(\", grp.label, \"*':')~~~\", \n                                      eq.label, sep = \"\"))),\n               formula = formula)\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-23-1.svg){fig-align='center'}\n:::\n:::\n\n\nFacets are also supported.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(my.data, aes(x, y2)) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(aes(label = after_stat(eq.label)),\n               formula = formula) +\n  facet_wrap(facets = vars(group), scales = \"free_y\", ncol = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-24-1.svg){fig-align='center'}\n:::\n:::\n\n\nIn the stats defined in 'ggpmsic' the fit method function can modify the\nmodel passed as argument because the one used to build the equation is\nretrieved from the fitted model object when possible. In this example, a\nlinear regression is fitted if the slope is significant, but if not the\nmean is reported, both graphically and numerically.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# user defined fit method removes the slope if \n# the slope is not significant\npoly_or_mean <- function(formula, data, ...) {\n   fm <- lm(formula = formula, data = data, ...)\n   if (anova(fm)[[\"Pr(>F)\"]][1] > 0.1) {\n      lm(formula = y ~ 1, data = data, ...)\n   } else {\n      fm\n   }\n}\n\n# we create a plot as usual, but with our method\nggplot(mpg, aes(displ, hwy)) +\n   geom_point() +\n   stat_poly_line(method = \"poly_or_mean\") +\n   stat_poly_eq(method = poly_or_mean,\n   aes(label = after_stat(eq.label)),\n   label.x = \"right\") +\n   theme(legend.position = \"bottom\") +\n   facet_wrap(~class, ncol = 2)\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-25-1.svg){fig-align='center'}\n:::\n:::\n\n\nFaceting works also with free *x* and/or *y* scales in panels.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(my.data, aes(x, y2, fill = block)) +\n  geom_point(shape = 21, size = 3) +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(aes(label = after_stat(rr.label)), size = 3,\n               geom = \"label_npc\", alpha = 0.33,\n               formula = formula) +\n  facet_wrap(~group, scales = \"free_y\") +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-26-1.svg){fig-align='center'}\n:::\n:::\n\n\nFaceting works also with free *x* and/or *y* scales in panels when the\nposition of labels is set by a string.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(my.data, aes(x, y2, fill = block)) +\n  geom_point(shape = 21, size = 3) +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(use_label(\"R2\"), size = 3,\n               geom = \"label_npc\", alpha = 0.33,\n               formula = formula,\n               label.x = \"right\", label.y = \"bottom\",\n               rr.digits = 3) +\n  stat_poly_eq(use_label(c(\"F\", \"P\")),\n               size = 3,\n               geom = \"label_npc\", alpha = 0.33,\n               formula = formula) +\n  facet_wrap(~group, scales = \"free_y\") +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-27-1.svg){fig-align='center'}\n:::\n:::\n\n\nSome artificial data with rather high random variation on both _x_ and _y_.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(94321)\na <- (1:100) / 10\nx <- a + rnorm(length(x), sd = 1)\ny <- a + rnorm(length(x), sd = 2)\nmy_linear.data <- data.frame(x = x, y = y)\n```\n:::\n\n\nLinear regression through the origin.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# model with intercept = 0\nformula <- y ~ x + 0\nggplot(my_linear.data, aes(x, y)) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(formula = formula,\n               mapping = use_label(\"eq\"))\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-29-1.svg){fig-align='center'}\n:::\n:::\n\n\nRegressions of *y* on *x* and *x* on *y* in the same plot. The lines are\ndrawn for the range of the explanatory variable, which differs in this\ncase between the two fits.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# the default for formula is y ~ x\nggplot(my_linear.data, aes(x, y)) +\n  geom_point() +\n  stat_poly_line(color = \"blue\") +\n  stat_poly_eq(mapping = use_label(c(\"R2\", \"eq\")), \n               color = \"blue\") +\n  stat_poly_line(color = \"red\", \n                 orientation = \"y\") +\n  stat_poly_eq(mapping = use_label(c(\"R2\", \"eq\")), \n               color = \"red\", \n               orientation = \"y\",\n               label.y = 0.9)\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-30-1.svg){fig-align='center'}\n:::\n:::\n\n\n### Alternatives\n\n::: callout-tip\nPackage 'ggpubr' provides a renamed copy of `stat_poly_eq()` taken from\nan old version of 'ggpmisc'. The version in 'ggpubr' is much more\nlimited in its functionality and even contains bugs. The line drawing\ncode in `stat_smooth()` from 'ggplot2' was used as a basis for\n`stat_poly_line()`, the main difference is that by default it uses\n`lm()` as method irrespective of the data size while `stat_smooth()`\nswitches to using splines for large numbers of observations.\n:::\n\n## Major axis regression\n\nIf *x* and *y* are both subject to random errors, and none is clearly\nthe cause of the other, we should use major axis regression instead of\nlinear regression.\n\nThe examples in this section make use of `stat_ma_line()` and `stat_ma_eq()`\nfrom package 'ggpmisc'. Please, see the [help page for\n`stat_ma_line()`](https://docs.r4photobiology.info/ggpmisc/reference/stat_ma_line.html)\nand the [help page for\n`stat_poly_eq()`](https://docs.r4photobiology.info/ggpmisc/reference/stat_ma_eq.html)\nfor details.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(my_linear.data, aes(x, y)) +\n  geom_point() +\n  stat_ma_line() +\n  stat_ma_eq(mapping = use_label(c(\"R2\", \"eq\")))\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-31-1.svg){fig-align='center'}\n:::\n:::\n\n\n::: callout-tip\nNo alternatives I know of.\n:::\n\n## Quantile regression\n\nQuantile regression is frequently used is some disciplines like\nEconomics but less frequently in other fields. It is robust and can be\nrather easily interpreted based on its similarity to the well known box\nplots.\n\nThe examples in this section make use of `stat_quant_line()`,\n`stat_quant_band()` and `stat_quant_eq()` from package 'ggpmisc'. Please, see\nthe [help page for\n`stat_quant_line()`](https://docs.r4photobiology.info/ggpmisc/reference/stat_quant_line.html),\n[help page for\n`stat_quant_band()`](https://docs.r4photobiology.info/ggpmisc/reference/stat_quant_band.html)\nand the [help page for\n`stat_quant_eq()`](https://docs.r4photobiology.info/ggpmisc/reference/stat_quant_eq.html)\nfor details.\n\n::: callout-caution\nQuantile regression fits are done by numerical approximation, and\nfrequently generate warnings for non-unique solutions or similar\nproblems. Their importance needs to be assessed by users. In the\nexamples below they seem mostly unimportant given the large number of\nobservations and have been silenced in the output.\n:::\n\nA median regression with a band limited by the upper and lower quartile\nregressions.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# the default for formula is y ~ x\nggplot(my_linear.data, aes(x, y)) +\n  geom_point() +\n  stat_quant_band() +\n  stat_quant_eq(quantiles = 0.5)\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-32-1.svg){fig-align='center'}\n:::\n:::\n\n\nMedian regression through the origin.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# model with intercept = 0\nformula <- y ~ x + 0\nggplot(my_linear.data, aes(x, y)) +\n  geom_point() +\n  stat_quant_band(formula = formula) +\n  stat_quant_eq(formula = formula, quantiles = 0.5)\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-33-1.svg){fig-align='center'}\n:::\n:::\n\n\nQuantile regressions of _y_ on _x_ and _x_ on _y_.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# the default for formula is y ~ x\nggplot(my_linear.data, aes(x, y)) +\n  geom_point() +\n  stat_quant_band(color = \"blue\") +\n  stat_quant_eq(quantiles = 0.5, color = \"blue\") +\n  stat_quant_band(color = \"red\", \n                 orientation = \"y\") +\n  stat_quant_eq(quantiles = 0.5, color = \"red\", \n               orientation = \"y\", label.y = 0.9)\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-34-1.svg){fig-align='center'}\n:::\n:::\n\n\nFitting a polynomial by quantile regression.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(my.data, aes(x, y)) +\n  geom_point() +\n  stat_quant_band(formula = y ~ poly(x, 2)) +\n  stat_quant_eq(formula = y ~ poly(x, 2), quantiles = 0.5)\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-35-1.svg){fig-align='center'}\n:::\n:::\n\n\nTwo quantiles are by default plotted as lines,\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(my.data, aes(x, y)) +\n  geom_point() +\n  stat_quant_line(formula = y ~ poly(x, 2), quantiles = c(0.05, 0.95)) +\n  stat_quant_eq(formula = y ~ poly(x, 2), quantiles = c(0.05, 0.95))\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-36-1.svg){fig-align='center'}\n:::\n:::\n\n\nA single quantile, here the median, is plotted as a line plus a\nconfidence band.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(my.data, aes(x, y)) +\n  geom_point() +\n  stat_quant_line(formula = y ~ poly(x, 2), quantiles = 0.5) +\n  stat_quant_eq(formula = y ~ poly(x, 2), quantiles = 0.5)\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-37-1.svg){fig-align='center'}\n:::\n:::\n\n\nEquations labelled by quantile.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(my.data, aes(x, y)) +\n  geom_point() +\n  stat_quant_band(formula = y ~ poly(x, 2), \n                  color = \"black\", fill = \"grey60\") +\n  stat_quant_eq(aes(label = paste(after_stat(grp.label), \"*\\\": \\\"*\",\n                                  after_stat(eq.label), sep = \"\")),\n                formula = y ~ poly(x, 2)) +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-38-1.svg){fig-align='center'}\n:::\n:::\n\n\nEquations labelled by group and quantile.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(my.data, aes(x, y, group = group, linetype = group, \n                    shape = group, grp.label = group)) +\n  geom_point() +\n  stat_quant_line(formula = y ~ poly(x, 2), \n                  quantiles = c(0.1, 0.9), \n                  color = \"black\") +\n  stat_quant_eq(aes(label = paste(after_stat(grp.label), \"*\\\": \\\"*\",\n                                  after_stat(eq.label), sep = \"\")),\n                formula = y ~ poly(x, 2), \n                quantiles = c(0.1, 0.9)) +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-39-1.svg){fig-align='center'}\n:::\n:::\n\n\n### Alternatives\n\n::: callout-tip\nPackage 'ggplot2' defines `stat_quantile()` which can be used to plot as\na line some types of quantile regression fits, but is less flexible than\n`stat_quant_line()` and `stat_quant_band()`.\n:::\n\n## Non-linear models\n\nThe examples in previous sections were based on ready assembled labels. Here\nwe show examples of how to generate labels for equations and other parameter\nestimates with an approach applicable to many different types of models.\n\nThe examples in this section make use of `stat_fit_tidy()` from package\n'ggpmisc'. Please, see its [help page](https://docs.r4photobiology.info/ggpmisc/reference/stat_fit_tidy.html)\nfor details.\n\nWe use as example a fit of the Michaelis-Menthen equation of reaction quinetics,\na function that is non-linear in its parameters.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\n# We use methods from package 'broom'\nlibrary(broom)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmicmen.formula <- y ~ SSmicmen(x, Vm, K) \nggplot(Puromycin, aes(conc, rate, colour = state)) +\n  geom_point() +\n  geom_smooth(method = \"nls\", \n              formula = micmen.formula,\n              se = FALSE) +\n  stat_fit_tidy(method = \"nls\", \n                method.args = list(formula = micmen.formula),\n                label.x = \"right\",\n                label.y = \"bottom\",\n                aes(label = paste(\"V[m]~`=`~\", signif(after_stat(Vm_estimate), digits = 3),\n                                  \"%+-%\", signif(after_stat(Vm_se), digits = 2),\n                                  \"~~~~K~`=`~\", signif(after_stat(K_estimate), digits = 3),\n                                  \"%+-%\", signif(after_stat(K_se), digits = 2),\n                                  sep = \"\")),\n                parse = TRUE) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-41-1.svg){fig-align='center'}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmicmen.formula <- y ~ SSmicmen(x, Vm, K) \nggplot(Puromycin, aes(conc, rate, colour = state)) +\n  geom_point() +\n  geom_smooth(method = \"nls\", \n              formula = micmen.formula,\n              se = FALSE) +\n  stat_fit_tidy(method = \"nls\", \n                method.args = list(formula = micmen.formula),\n                label.x = \"center\",\n                label.y = \"bottom\",\n                vstep = 0, hstep = -0.3,\n                aes(label = paste(\"V~`=`~frac(\", signif(after_stat(Vm_estimate), digits = 2), \"~C,\",\n                                  signif(after_stat(K_estimate), digits = 2), \"+C)\",\n                                  sep = \"\")),\n                parse = TRUE) +\n  labs(x = \"C\", y = \"V\") +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](plot-equations_files/figure-html/unnamed-chunk-42-1.svg){fig-align='center'}\n:::\n:::\n\n\n### Alternatives\n\n::: callout-tip\nIn all cases it is possible to do the model fitting before creating the plot, assembling\nlabels in one's own R code and passing them to `ggplot()` as data. The\npossibilities are nearly unlimited but implementing them, depending on one's\nown familiarity with R and 'ggplot2' can become very time consuming. I have\nin part written 'ggpp' and 'ggpmisc' to avoid as a user having to remind\nmyself of how to write such code repeatedly. My hope is that others will also\nsave time and effort by using the packages I have developed.\n:::\n",
    "supporting": [
      "plot-equations_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}