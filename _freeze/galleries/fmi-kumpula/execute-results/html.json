{
  "hash": "866e5157fcade6a15bb0c9e654a83ec7",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Weather data for Finland from FMI\"\nsubtitle: \"**FMI** = _Finnish Meteorological Institute_, or _Ilmatieteen laitos_\"\nauthor: \"Pedro J. Aphalo\"\ndate: \"2023-04-15\"\ndate-modified: \"2023-08-01\"\ntoc: true\ncode-fold: false\ncategories: [Using R]\nkeywords: [R packages, weather data, FMI, Finnish Meteorological Institute]\nabstract: |\n  Examples of R code for retrieval near real-time and historical weather data for observation stations in Finland. The examples dowload the data from the open access database of the Finnish Meteorological Institute.\neditor: \n  markdown: \n    wrap: 72\n---\n\n\n# Introduction\n\nThe [Finnish Meteorological Institute](https://en.ilmatieteenlaitos.fi/)\nshares a large amount of data openly. One way of accessing observations\nfrom meteorological stations is through its [open data web\nsite](https://en.ilmatieteenlaitos.fi/download-observations). Data can\nbe obtained both by manually downloading them or automatically using a\ncomputer program or script through calls to an API interface. Package\n'fmi2' implements calls to some of the [WPS\nAPI](https://en.ilmatieteenlaitos.fi/open-data-manual) functions,\nallowing downloads directly from R.\n\nThe FMI also makes available [climate data from 1961 to the\npresent](https://www.climateguide.fi/articles/from-point-observations-to-regionally-comprehensive-climate-grids/)\nspatially interpolated to a 10 km x 10 km grid. However, I haven't found\nan API to access the gridded data.\n\n[Monthly climatology for individual weather stations](https://www.ilmatieteenlaitos.fi/ilmastollinen-vertailukausi) is also available. There are separate pages for each variable.\n\nI find it convenient to use an R scrip to download weather data from FMI,\nbut data can also be downloaded through FMI's web pages. The scrip below caches a local copy of the data, and when run again appends the new data.\n\nThe FMI WPS API has limits to the amount of data that can be downloaded\nper query. In addition if we need to frequently retrieve fresh data from\nthe same station or group of stations we can retrieve the missing data\nand append it to those previously downloaded instead of fetching again\nand again the same data. Of course if data changes retrospectively in\nthe FMI service we will want to retrieve a fresh copy also of the older\ndata.\n\n# Installing R package 'fmi2'\n\nThe original version is available at (https://github.com/rOpenGov/fmi2).\n\nAn edited version that adds a function to retrieve solar radiation and a\nversion of this file as a second vignette is available at\n(https://github.com/aphalo/fmi2). The package can be installed directly\nfrom GitHub with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nremotes::install_github(\"https://github.com/aphalo/fmi2\", \n                        ref = \"HY2-develop\")\n```\n:::\n\n\nIts dependencies may need to be installed manually from CRAN.\n\n::: callout-note\nThe [documentation for the modified 'fmi2' package](https://docs.r4photobiology.info/fmi2-fork/) is available on-line and can be read without need to locally install the package.\n:::\n\n# Set up\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(fmi2)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(sf)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLinking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.3.1; sf_use_s2() is TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(lubridate)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'lubridate'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(ggpmisc)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: ggpp\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRegistered S3 methods overwritten by 'ggpp':\n  method                  from   \n  heightDetails.titleGrob ggplot2\n  widthDetails.titleGrob  ggplot2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'ggpp'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:ggplot2':\n\n    annotate\n```\n\n\n:::\n:::\n\n\nWe can query by FMI station ID, for simplicity we set it here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ID code of the station from where we fetch data\nstn_fmisid <- 101004 # Kumpula, change as needed, both weather and radiation\n# stn_fmisid <- 101154 # Lammi, change as needed, only weather\nstarttime.char <- \"2022-12-31 22:00\" # UTC midnight in Finland\n```\n:::\n\n\nWe can query information about the station.\n\n# Downloading hourly data values\n\nWe store data locally in a file and if the file exists load and append\nto it the missing data between its end and \"now\". We need to be careful\nwith time zones!! It is simplest to use UTC for the data and only change\nthe time zone for plotting.\n\n::: To force the data to be retrieved again, we only need to delete the\nfile we use to store it locally (or \"cache\"). \n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!file.exists(\"fmi-weather-data-wide.Rda\")) {\n  # Used only once or when replacing all data\n  starttime <- ymd_hm(starttime.char, tz = \"UTC\")\n  wide_weather_data <- data.frame()\n} else {\n  load(\"fmi-weather-data-wide.Rda\")\n  # we start 59 min after end of previously downloaded data\n  starttime <-force_tz(max(wide_weather_data$time), tzone = \"UTC\") + minutes(59)\n}\n\n# endtime <- trunc(now(), units = \"mins\")\nendtime <- starttime # do not read new data\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n  # we read the new data to a new dataframe\n  # (to avoid appending repeatedly to a long one)\n  new_wide_data <- data.frame()\n  while (starttime < endtime) {\n    sliceendtime <- starttime + days(28) # keep query size at max of 4 weeks\n    if (sliceendtime > endtime) {\n      sliceendtime <- endtime\n    }\n    stn_data <- obs_weather_hourly(starttime = as.character(starttime),\n                                   endtime = as.character(sliceendtime),\n                                   fmisid = stn_fmisid)\n\n    slice_data <- stn_data %>%\n      tidyr::spread(variable, value) %>%\n      # convert the sf object into a regular tibble\n      sf::st_set_geometry(NULL)\n\n    new_wide_data <- rbind(new_wide_data, slice_data)\n    starttime <- sliceendtime + minutes(1)\n    cat(\".\")\n  }\n\n  range(new_wide_data$time) # freshly read\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in min(x, na.rm = na.rm): no non-missing arguments to min; returning\nInf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in max(x, na.rm = na.rm): no non-missing arguments to max; returning\n-Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  Inf -Inf\n```\n\n\n:::\n\n```{.r .cell-code}\n  wide_weather_data <- rbind(wide_weather_data, new_wide_data)\n  range(wide_weather_data$time) # all data to be saved\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2022-12-31 22:00:00 UTC\" \"2023-08-01 12:00:00 UTC\"\n```\n\n\n:::\n\n```{.r .cell-code}\n  colnames(wide_weather_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"time\"           \"PA_PT1H_AVG\"    \"PRA_PT1H_ACC\"   \"PRI_PT1H_MAX\"  \n [5] \"RH_PT1H_AVG\"    \"TA_PT1H_AVG\"    \"TA_PT1H_MAX\"    \"TA_PT1H_MIN\"   \n [9] \"WAWA_PT1H_RANK\" \"WD_PT1H_AVG\"    \"WS_PT1H_AVG\"    \"WS_PT1H_MAX\"   \n[13] \"WS_PT1H_MIN\"   \n```\n\n\n:::\n\n```{.r .cell-code}\n  save(wide_weather_data, file = \"fmi-weather-data-wide.Rda\")\n```\n:::\n\n\nThe description of the variables can be obtained from the server.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfmi2::describe_variables(colnames(wide_weather_data)[-1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 6\n   variable       label           base_phenomenon unit  stat_function agg_period\n   <chr>          <chr>           <chr>           <chr> <chr>         <chr>     \n 1 PA_PT1H_AVG    Air pressure    Air pressure    hPa   avg           PT1H      \n 2 PRA_PT1H_ACC   Precipitation … Amount of prec… mm    acc           PT1H      \n 3 PRI_PT1H_MAX   Maximum precip… Amount of prec… mm/h  max           PT1H      \n 4 RH_PT1H_AVG    Relative humid… Humidity        %     avg           PT1H      \n 5 TA_PT1H_AVG    Air temperature Temperature     degC  avg           PT1H      \n 6 TA_PT1H_MAX    Highest temper… Temperature     degC  max           PT1H      \n 7 TA_PT1H_MIN    Lowest tempera… Temperature     degC  min           PT1H      \n 8 WAWA_PT1H_RANK Present weathe… Weather         <NA>  rank          PT1H      \n 9 WD_PT1H_AVG    Wind direction  Wind            deg   avg           PT1H      \n10 WS_PT1H_AVG    Wind speed      Wind            m/s   avg           PT1H      \n11 WS_PT1H_MAX    Maximum wind s… Wind            m/s   max           PT1H      \n12 WS_PT1H_MIN    Minimum wind s… Wind            m/s   min           PT1H      \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(wide_weather_data, aes(with_tz(time, tzone = \"EET\"), TA_PT1H_AVG)) +\n  geom_line()\n```\n\n::: {.cell-output-display}\n![](fmi-kumpula_files/figure-html/unnamed-chunk-7-1.svg)\n:::\n:::\n\n\n# Downloading radiation data at 1 min\n\nThe station ID was set above, and we use it again. However, FEW WEATHER STATIONS measure radiation! e.g., Kumpula does, but Lammi does not.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!file.exists(\"fmi-sun-data-wide.Rda\")) {\n  # Used only once or when replacing all data\n  starttime.char <- \"2023-01-15 22:00\"  # UTC at midnight in Finland\n  starttime <- ymd_hm(starttime.char)\n  wide_sun_data <- data.frame()\n} else {\n  load(\"fmi-sun-data-wide.Rda\")\n  # we start 1 h after end of previously downloaded data\n  starttime <- max(wide_sun_data$time) + minutes(1) + hours(2) # convert to UTC + 2h\n}\n\n# endtime <- trunc(now() - minutes(30), units = \"mins\")\nendtime <- starttime # do not read new data\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# we read the new data to a new dataframe\n# (to avoid appending repeatedly to a long one)\nnew_wide_data <- data.frame()\nwhile (starttime < endtime) {\n  sliceendtime <- starttime + days(1) # keep query size at max of 1 week\n  if (sliceendtime > endtime) {\n    sliceendtime <- endtime\n  }\n  stn_data <- obs_radiation_minute(starttime = as.character(starttime),\n                                       endtime = as.character(sliceendtime),\n                                       fmisid = 101004)\n  slice_data <- stn_data %>%\n    tidyr::spread(variable, value) %>%\n    # convert the sf object into a regular tibble\n    sf::st_set_geometry(NULL)\n\n  new_wide_data <- rbind(new_wide_data, slice_data)\n  starttime <- sliceendtime + minutes(1)\n  cat(\".\")\n}\n\nrange(new_wide_data$time)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in min(x, na.rm = na.rm): no non-missing arguments to min; returning\nInf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in max(x, na.rm = na.rm): no non-missing arguments to max; returning\n-Inf\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  Inf -Inf\n```\n\n\n:::\n\n```{.r .cell-code}\nwide_sun_data <- rbind(wide_sun_data, new_wide_data)\nrange(wide_sun_data$time)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2023-01-15 22:00:00 UTC\" \"2023-06-29 20:57:00 UTC\"\n```\n\n\n:::\n\n```{.r .cell-code}\ncolnames(wide_sun_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"time\"       \"DIFF_1MIN\"  \"DIR_1MIN\"   \"GLOB_1MIN\"  \"LWIN_1MIN\" \n [6] \"LWOUT_1MIN\" \"NET_1MIN\"   \"REFL_1MIN\"  \"SUND_1MIN\"  \"UVB_U\"     \n```\n\n\n:::\n\n```{.r .cell-code}\nsave(wide_sun_data, file = \"fmi-sun-data-wide.Rda\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfmi2::describe_variables(colnames(wide_sun_data)[-1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 × 6\n  variable   label                base_phenomenon unit  stat_function agg_period\n  <chr>      <chr>                <chr>           <chr> <chr>         <chr>     \n1 DIFF_1MIN  \"Diffuse radiation\"  Solar radiation W/m2  avg           PT1M      \n2 DIR_1MIN   \"Direct solar radia… Solar radiation W/m2  avg           PT1M      \n3 GLOB_1MIN  \"Global radiation\"   Solar radiation W/m2  avg           PT1M      \n4 LWIN_1MIN  \"Long wave solar ra… UV radiation    W/m2  avg           PT1M      \n5 LWOUT_1MIN \"Long wave outgoing… UV radiation    W/m2  avg           PT1M      \n6 NET_1MIN   \"Radiation balance\"  Solar radiation W/m2  avg           PT1M      \n7 REFL_1MIN  \"Reflected radiatio… Solar radiation W/m2  avg           PT1M      \n8 SUND_1MIN  \"Sunshine duration\"  Sunshine durat… s     acc           PT1M      \n9 UVB_U      \"Ultraviolet irradi… UV radiation    index avg           PT1M      \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(wide_sun_data, aes(with_tz(time, tzone = \"EET\"), GLOB_1MIN)) +\n  geom_line()\n```\n\n::: {.cell-output-display}\n![](fmi-kumpula_files/figure-html/unnamed-chunk-11-1.svg)\n:::\n:::\n",
    "supporting": [
      "fmi-kumpula_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}