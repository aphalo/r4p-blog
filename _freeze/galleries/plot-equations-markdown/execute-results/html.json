{
  "hash": "9999a810b6f0772685b64ff32620ef72",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Fitted-model labels in Markdown\"\nsubtitle: \"'ggpmisc' together with 'ggtext'\"\nauthor: \"Pedro J. Aphalo\"\ndate: \"2024-06-01\"\ndate-modified: \"2024-06-08\"\nkeywords: [ggplot2 pkg, ggpp pkg, ggpmisc pkg, data labels, plot annotations, model equations]\ncategories: [Plotting examples]\neditor: \n  markdown: \n    wrap: 72\ncode-fold: true\nformat:\n  html: \n    code-link: true\n    code-tools: true\nabstract: |\n  Example R code for plots with predictions from fitted models labelled with model fitted equations, parameter estimates, _R_<sup>2</sup>, _F_-value, _P_-value, etc. Polynomial regression, quantile regression, major-axis regression, robust linear model fits as well as non-linear regression are examplified. Markdown encoded labels make use of statistics from package 'ggpmisc' and geometries fron 'ggtext'.\ndraft: false\n---\n\n\n::: callout-tip\nIn this page code chunks are \"folded\" so as to decrease the clutter when\nsearching for examples. Above each plot you will find one or more \"folded\" code\nchuncks signalled by a small triangle followed by \"Code\". Clicking on the\ntriangle \"unfolds\" the code chunk making visible the R code used to produce the\nplot.\n\nThe code in the chunks can be copied by clicking on the top right\ncorner, where an icon appears when the mouse cursor hovers over the code\nlisting.\n\nThe `</> Code` drop down menu to the right of the page title makes it possible to unfold all code chunks and to view the Quarto source of the whole web page.\n\nNames of functions and other R objects are linked to the corresponding on-line help pages. The names of R extension packages are linked to their documentation web sites when available.\n:::\n\n# Introduction\n\nHere you will find examples of ggplots with labels for fitted model equations,\nand various parameter estimates. The labels have been\nadded to the plots with geometries defined in package ['ggtext'](https://wilkelab.org/ggtext/) and statistics from package ['ggpmisc'](https://docs.r4photobiology.info/ggpmisc/) both available at CRAN.\n\n**Currently, the labels are not always correctly rendered by `marquee::geom_marquee()`, which is at an early stage of development.**\n\n_The code examples in this page are edited versions on those in [a page with equivalent labels using R plotmath expressions](plot-equations.qmd)._\n\n::: callout-warning\nThe statistics from 'ggpmisc' use by default the geometries from 'ggpp'. These geometries support like `ggplot2::geom_text()` and `ggplot2::geom_label()` character string `\"inward\"` for justification. We use in the examples in the page explicit arguments for justification and label positions as `geom_richtext()` does not seem to support these rather recent feature of geometries from 'ggplot2' also added to 'ggpp'.\n:::\n\n::: callout-important\nOne needs to always check that annotations do not occlude anything\nsignificant, such as observations in the base plot. This needs special\ncare when using annotations together with batch plotting. Either ensure\nthat the scale limits of the base plot are expanded to avoid overlap or\nthat the layer with the equations is the lowest one, i.e., added to the\nplot first.\n:::\n\n# Preliminaries\n\nThe code used is shown on-demand above each plot and can be copied. We\nfirst load the packages we will use.\n\nWhen package [ggpmisc](https://docs.r4photobiology.info/ggpmisc/) is loaded and attached, packages [ggpp](https://docs.r4photobiology.info/ggpp/) and\n[ggplot2](https://ggplot2.tidyverse.org/) are also attached. The only function from [ggplot2](https://ggplot2.tidyverse.org/) that is\nredefined by [ggpp](https://docs.r4photobiology.info/ggpp/) is `annotate()`, which remains backwards compatible\nwith [ggplot2](https://ggplot2.tidyverse.org/).\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(ggpmisc)\nlibrary(ggtext)\nlibrary(dplyr)\n```\n:::\n\n\n# Linear correlation\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# generate artificial data for a linear relationship\n# two groups with different standard deviation around a slope = 1\nset.seed(94321)\nx <- (1:100) / 10\nyA <- x + rnorm(length(x), sd = 2)\nyB <- x + rnorm(length(x), sd = 8)\ndf1 <- data.frame(x = rep(x, 2),\n                  y = c(yA, yB),\n                  group = rep(c(\"A\", \"B\"), rep(length(x), 2L)))\n```\n:::\n\n\nThe examples in this section make use of `stat_correlation()` from package\n[ggpmisc](https://docs.r4photobiology.info/ggpmisc/).\n\nAll the examples, except the one below, use the default border and fill of `geom_richtext()`, setting the\n`label.size = 0` and `fill = NA` makes the output similar to that of \n`geom_text()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(subset(df1, group == \"A\"), \n       aes(x, y)) +\n  geom_point() +\n  stat_correlation(geom = \"richtext\", \n                   label.size = 0,\n                   fill = NA,\n                   hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-4-1.svg){fig-align='center'}\n:::\n:::\n\n\nPearson correlation.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(subset(df1, group == \"A\"), \n       aes(x, y)) +\n  geom_point() +\n  stat_correlation(geom = \"richtext\", hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-5-1.svg){fig-align='center'}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(subset(df1, group == \"A\"), \n       aes(x, y)) +\n  geom_point() +\n  stat_correlation(small.r = TRUE, geom = \"richtext\", \n                   hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-6-1.svg){fig-align='center'}\n:::\n:::\n\n\nSpearman correlation. (The default is to not compute the confidence interval.)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(subset(df1, group == \"A\"), \n       aes(x, y)) +\n  geom_point() +\n  stat_correlation(method = \"spearman\", geom = \"richtext\", \n                   hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-7-1.svg){fig-align='center'}\n:::\n:::\n\nKendall correlation. (The default is to not compute the confidence interval.)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(subset(df1, group == \"A\"), \n       aes(x, y)) +\n  geom_point() +\n  stat_correlation(method = \"kendall\", geom = \"richtext\", \n                   hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-8-1.svg){fig-align='center'}\n:::\n:::\n\n\nSelect which labels to show in plot, number of digits to display.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(subset(df1, group == \"A\"), aes(x, y)) +\n  geom_point() +\n  stat_correlation(mapping = use_label(\"R\", \"P\", \"n\", sep = \", \"),\n                   r.digits = 3, p.digits = Inf, geom = \"richtext\",\n                   hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-9-1.svg){fig-align='center'}\n:::\n:::\n\n\nSelect which labels to show in plot.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(subset(df1, group == \"A\"), aes(x, y)) +\n  geom_point() +\n  stat_correlation(mapping = use_label(\"R\", \"t\", \"P\", \"n\", sep = \", \"), \n                   geom = \"richtext\", \n                   hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-10-1.svg){fig-align='center'}\n:::\n:::\n\n\nConfidence interval for R (Pearson's correlation).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(subset(df1, group == \"A\"), aes(x, y)) +\n  geom_point() +\n  stat_correlation(mapping = use_label(\"R\", \"R.confint\", sep = \", \"), \n                   geom = \"richtext\",\n                   hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-11-1.svg){fig-align='center'}\n:::\n:::\n\n\nConfidence interval for Spearman's correlation.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(subset(df1, group == \"A\"), \n       aes(x, y)) +\n  geom_point() +\n  stat_correlation(mapping = use_label(\"R\", \"R.confint\", sep = \", \"),\n                   r.conf.level = 0.95,\n                   method = \"spearman\", geom = \"richtext\",\n                   hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-12-1.svg){fig-align='center'}\n:::\n:::\n\n\n\nGrouping supported.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(df1, aes(x, y, color = group)) +\n  geom_point() +\n  stat_correlation(geom = \"richtext\",\n                   vstep = 0.1,\n                   hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-13-1.svg){fig-align='center'}\n:::\n:::\n\n\nFacets supported.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(df1, aes(x, y)) +\n  geom_point() +\n  stat_correlation(label.x = \"right\", label.y = \"bottom\", \n                   geom = \"richtext\",\n                   hjust = 1, vjust = 0) +\n  facet_wrap(~group)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-14-1.svg){fig-align='center'}\n:::\n:::\n\n\nHighlighting based on estimates, here estimated *R* but it is possible\nto use other estimates like *P*-value.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(df1, aes(x, y)) +\n  geom_point() +\n  stat_correlation(geom = \"richtext\", \n                   hjust = 0, vjust = 1,\n                   mapping = \n                     aes(color = ifelse(after_stat(cor) > 0.5,\n                                        \"red\", \"black\"))) +\n  scale_color_identity() +\n  facet_wrap(~group)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-15-1.svg){fig-align='center'}\n:::\n:::\n\n\n## Alternatives\n\n::: callout-tip\nPackage 'ggpubr' provides alternative approaches to correlation testing\nand reporting.\n:::\n\n# OLS regression with polynomials\n\nPolynomials can be fitted as linear models by the method of ordinary least squares (OLS), but many other linear models exist. Robust and resistant variations also exist, based on a very similar user interface.\n\nThe most common use case of a polynomial is linear regression. Polynomials are\nvery frequently used, and in the case of linear regression the role of\nparameters can be easily recognized.\n\nThe examples in this section make use of `stat_poly_line()` and `stat_poly_eq()`\nfrom package [ggpmisc](https://docs.r4photobiology.info/ggpmisc/). The model `formula` accepted follows the same format as accepted by `lm()`. However, automatic equation labels are generated only for subset of these.\n\n::: callout-warning\n\nAs is the case in general for model fitting with R, function `poly()` can be\nused within model formulae, to describe polynomials. The default behaviour of\n`poly()` is to generate orthogonal polynomials by centring the data. This\nhelps with computation, but produces coefficient estimates that are not directly\ninterpretable. Thus, `eq.label` is set to `NA` unless `raw = TRUE` is passed in\nthe call to `poly()` to disable the generation of orthogonal polynomials.\n\nAs `predict()` methods take into account whether the polynomial is orthogonal or\nraw, the plotted lines differ only in case of numerical accuracy problems. On\nthe other hand the coefficient estimates are very different.\n\n:::\n\n::: callout-tip\n\nIn statistics from 'ggplot2' and extension packages, model formulas are always\ndefined using the name of aesthetics, _x_ and _y_, not the names of the mapped\nvariables. By default, equations added with `stat_poly_eq()` make use of _x_ and\n_y_, but this can be altered by passing arguments in the call.\n\n:::\n\nThe model corresponding to linear regression, `y ~ x`, is a first degree\npolynomial, and it is the default of both statistics. The default \n`method = \"lm\"` fits it as a Linear Model (LM) by OLS.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(df1, aes(x, y)) +\n  geom_point() +\n  stat_poly_line() +\n  stat_poly_eq(use_label(\"eq\"), \n               label.x = \"right\", label.y = \"bottom\", \n                   geom = \"richtext\",\n                   hjust = 1, vjust = 0) +\n  facet_wrap(~group)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-16-1.svg){fig-align='center'}\n:::\n:::\n\n\nMost likely the variables mapped onto aesthetics `x` and `y` have different\nnames than the aesthetics. If we use a symbol to represent these variables, we\nwill want to use these same symbols in the equation.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(df1, aes(x, y)) +\n  geom_point() +\n  stat_poly_line() +\n  stat_poly_eq(use_label(\"eq\"), \n               eq.with.lhs = \"_t_ = \", \n               eq.x.rhs = \"_E_\",\n               label.x = \"right\", label.y = \"bottom\", \n               geom = \"richtext\",\n               hjust = 1, vjust = 0) +\nlabs(x = expression(\"Irradiance, \"*italic(E)~~(W~m^{-2})),\n       y = expression(\"Temperature, \"*italic(t)~~(degree*\"C\"))) +\n  facet_wrap(~group)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-17-1.svg){fig-align='center'}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(4321)\n# generate artificial data for a 3rd degree polynomial\nx <- 1:100\ny <- (x + x^2 + x^3) + rnorm(length(x), mean = 0, sd = mean(x^3) / 4)\ny <- y / max(y)\ndf2 <- data.frame(x, \n                  y, \n                  group = c(\"A\", \"B\"), \n                  y2 = y * c(1, 2) + c(0, 0.2),\n                  block = c(\"a\", \"a\", \"b\", \"b\"),\n                  wt = sqrt(x))\n```\n:::\n\n\n$R^2$ is the default label, as its estimate is always available, even when\nthe model formula passed as argument is not that of a full polynomial.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(df2, aes(x, y)) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(formula = formula, geom = \"richtext\", hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-19-1.svg){fig-align='center'}\n:::\n:::\n\n\nFitted model equation, available for polynomials with no missing terms. Here\nwe create the mapping with a call to `use_label()`, a convenience function that\ncan be called instead of `aes()` for conciseness.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(df2, aes(x, y)) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(mapping = use_label(\"eq\"), formula = formula, \n               geom = \"richtext\", hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-20-1.svg){fig-align='center'}\n:::\n:::\n\n\n$R_\\mathrm{adj}^2$ and *P*-value added separately. This is necessary if separate locations or colours are desired for different labels derived from the same\nmodel fit.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(df2, aes(x, y)) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(mapping = use_label(\"adj.R2\"), formula = formula, \n               geom = \"richtext\", hjust = 0, vjust = 1) +\n  stat_poly_eq(mapping = use_label(\"P\"), label.x = \"right\", label.y = \"bottom\", size = 3,\n               formula = formula, \n               geom = \"richtext\", hjust = 1, vjust = 0)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-21-1.svg){fig-align='center'}\n:::\n:::\n\n\nFitted model equation and $R_\\mathrm{adj}^2$. As seen above, function `use_label()` \npastes together multiple labels. Here we pass an argument to `sep`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(df2, aes(x, y)) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(mapping = use_label(c(\"eq\", \"adj.R2\"), sep = \"<br>_with_ \"),\n               formula = formula, geom = \"richtext\", hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-22-1.svg){fig-align='center'}\n:::\n:::\n\n\nEquation with no left-hand-side (lhs).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(df2, aes(x, y)) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(mapping = use_label(\"eq\"),\n               eq.with.lhs = FALSE,\n               formula = formula, geom = \"richtext\", hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-23-1.svg){fig-align='center'}\n:::\n:::\n\n\nVariable names in the equation set to be informative, and match the axis labels.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(df2, aes(x, y)) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(mapping = use_label(c(\"eq\", \"R2\", \"P\"), sep = \", \"),\n               eq.with.lhs = \"_h_ = \",\n               eq.x.rhs = \"_z_\",\n               formula = formula, \n               geom = \"richtext\", hjust = 0, vjust = 1) +\n  labs(x = expression(italic(z)), y = expression(italic(h)))\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-24-1.svg){fig-align='center'}\n:::\n:::\n\n\nEven Greek charactes and maths can be incorporated when needed.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 2, raw = TRUE)\nggplot(df2, aes(x, log10(y + 1e6))) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(mapping = use_label(\"eq\"),\n               eq.with.lhs = \"log<sub>10</sub>_&delta;_ + 10<sup>6</sup> = \",\n               eq.x.rhs = \"_&Omega;_\",\n               formula = formula, \n               geom = \"richtext\", hjust = 0, vjust = 1) +\n  labs(y = expression(plain(log)[10](italic(delta)+10^6)), \n       x = expression(Omega))\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-25-1.svg){fig-align='center'}\n:::\n:::\n\n\n::: callout-caution\n`stat_poly_eq()` by default assumes that the fitted polynomial has the variable\nmapped to the `x` or `y` aesthetic as explanatory variable depending on the\nmodel formula and argument passed to parameter `orientation`. It does not decode\nany transformations applied on the fly to `x` or `y`. In addition it does not\ngenerate `eq.label` for linear models that are not polynomials with no missing\nterms and terms entered in increasing order of their powers.\n\nIf a transformation is applied or any other deviation from a regular polynomial\nis passed to `formula`, it is still possible to use the labels for other fitted\nparameters. It is also possible to set `output.type = \"numeric\"` and manually\nbuild the equation label, using `sprintf()` as shown below, or a combination \nof `paste()` and `format()` or any other R function that can assemble a suitable\ncharacter string from the numeric values returned.\n\n_When using this non-automated approach, any valid linear model can be fitted._\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ I(x^2) # we apply a transformation to x within the formula\nggplot(df2, aes(x, y)) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(mapping = aes(label = sprintf_dm(\"y = %.3g x<sup>2</sup>\",\n                                                after_stat(b_0))), \n               output.type = \"numeric\",\n               formula = formula, \n               geom = \"richtext\", hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-26-1.svg){fig-align='center'}\n:::\n:::\n\n\nIn some cases, such as when applying a power as transformation and fitting higher\ndegree polynomials, one needs to manually build the R expression representing\nthe equation to simplify it.\n:::\n\nThe examples shown above also work with groups. _As in 'ggplot2', models are\nfitted separately to the data in each group._\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(df2, aes(x, y2, colour = group)) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(use_label(\"eq\"), \n               formula = formula, \n               vstep = 0.1, \n               geom = \"richtext\", hjust = 0, vjust = 1) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-27-1.svg){fig-align='center'}\n:::\n:::\n\n\nUsing colours to indicate the groups to which equations correspond is\nnot always best. Here we use textual labels pasted to the left of each equation.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(df2, aes(x, y2, linetype = group, grp.label = group)) +\n  geom_point() +\n  stat_poly_line(formula = formula, color = \"black\") +\n  stat_poly_eq(aes(label = after_stat(paste(\"**\", grp.label, \":**  \", \n                                      eq.label, sep = \"\"))),\n               formula = formula, geom = \"richtext\", \n               hjust = 0, vjust = 1, vstep = 0.1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-28-1.svg){fig-align='center'}\n:::\n:::\n\n\nFacets are also supported.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(df2, aes(x, y2)) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(aes(label = after_stat(eq.label)),\n               formula = formula, geom = \"richtext\", hjust = 0, vjust = 1) +\n  facet_wrap(facets = vars(group), scales = \"free_y\", ncol = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-29-1.svg){fig-align='center'}\n:::\n:::\n\n\nIn the stats defined in [ggpmsic](https://docs.r4photobiology.info/ggpmisc/) the\nfit method function can modify the model passed as argument because the one used\nto build the equation is retrieved, when possible, from the fitted model object.\nIn this example, a linear regression is fitted if the slope differs\nsignificantly from zero, but if not, the mean is reported, both graphically and\nnumerically.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# user defined fit method removes the slope if \n# the slope is not significant\npoly_or_mean <- function(formula, data, ...) {\n   fm <- lm(formula = formula, data = data, ...)\n   if (anova(fm)[[\"Pr(>F)\"]][1] > 0.1) {\n      lm(formula = y ~ 1, data = data, ...)\n   } else {\n      fm\n   }\n}\n\n# we create a plot as usual, but with our method\nggplot(mpg, aes(displ, hwy)) +\n   geom_point() +\n   stat_poly_line(method = \"poly_or_mean\") +\n   stat_poly_eq(method = poly_or_mean,\n                use_label(\"eq\"),\n                label.x = \"right\", \n                geom = \"richtext\", hjust = 1, vjust = 1) +\n   theme(legend.position = \"bottom\") +\n   facet_wrap(~class, ncol = 2)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-30-1.svg){fig-align='center'}\n:::\n:::\n\n\nFaceting works also with free *x* and/or *y* scales in panels.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(df2, aes(x, y2, fill = block)) +\n  geom_point(shape = 21, size = 3) +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(use_label(\"R2\"), \n               size = 3,\n               alpha = 0.33,\n               formula = formula,\n               geom = \"richtext\", \n               hjust = 0, vjust = 1, vstep = 0.1) +\n  facet_wrap(~group, scales = \"free_y\") +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-31-1.svg){fig-align='center'}\n:::\n:::\n\n\nFaceting works also with free *x* and/or *y* scales in panels when the\nposition of labels is set by a string.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nformula <- y ~ poly(x, 3, raw = TRUE)\nggplot(df2, aes(x, y2, fill = block)) +\n  geom_point(shape = 21, size = 3) +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(use_label(\"R2\"), size = 3,\n               alpha = 0.33,\n               formula = formula,\n               label.x = \"right\", label.y = \"bottom\",\n               rr.digits = 3,\n               geom = \"richtext\", hjust = 1, vjust = 0, vstep = 0.1) +\n  stat_poly_eq(use_label(c(\"F\", \"P\")),\n               size = 3,\n               alpha = 0.33,\n               formula = formula, \n               geom = \"richtext\", hjust = 0, vjust = 1, vstep = 0.1) +\n  facet_wrap(~group, scales = \"free_y\") +\n  theme(legend.position = \"top\")\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-32-1.svg){fig-align='center'}\n:::\n:::\n\n\nSome artificial data with rather high random variation on both _x_ and _y_.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(94321)\na <- (1:100) / 10\nx <- a + rnorm(length(x), sd = 1)\ny <- a + rnorm(length(x), sd = 2)\n\ndf3 <- data.frame(x = x, y = y, y5 = y + 5)\n```\n:::\n\n\nLinear regression through the origin.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# model with intercept = 0\nformula <- y ~ x + 0\nggplot(df3, aes(x, y)) +\n  geom_point() +\n  stat_poly_line(formula = formula) +\n  stat_poly_eq(formula = formula,\n               mapping = use_label(\"eq\"), \n               geom = \"richtext\", hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-34-1.svg){fig-align='center'}\n:::\n:::\n\n\n::: callout-caution\nThese two examples show how to fit only one of the two parameters of a linear\nregression using the statistics from 'ggpmisc'. These are unusual use cases but\nserve as examples of how simple transformations included in the model formula\nusing the identity function `I()` can be \"undone\" at the `after_stat()` stage.\nBoth examples use function `stage()`, available only in 'ggplot2' (>= 3.4.0).\n\nLinear regression with a fixed (instead of fitted) _y_-intercept (_y_ = 5 at _x_\n= 0) and a fitted slope.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(df3) +\n  stat_poly_line(mapping = aes(x = x, \n                               y = stage(start = y5, after_stat = y + 5),\n                               ymax = after_stat(ymax + 5),\n                               ymin = after_stat(ymin + 5)),\n                 formula = I(y - 5) ~ x + 0) +\n  stat_poly_eq(mapping = aes(x, y5, \n                             label = after_stat(paste(eq.label, \" + 5, \", rr.label))), \n               orientation = \"x\", \n               formula = I(y - 5) ~ x + 0, \n               geom = \"richtext\", hjust = 0, vjust = 1) +\n  geom_point(mapping = aes(x, y5), size = 2.5) +\n  ylab(\"y\")\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-35-1.svg){fig-align='center'}\n:::\n:::\n\n\nLinear regression with a fixed slope of 1:1 (instead of fitted) and a fitted\n_y_-intercept.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(df3) +\n  stat_poly_line(mapping = aes(x = x,\n                               y = stage(start = y5, after_stat = y + x - mean(x)),\n                               ymax = after_stat(ymax + x - mean(x)),\n                               ymin = after_stat(ymin + x - mean(x))),\n                 formula = y ~ 1) +\n  stat_poly_eq(mapping = aes(x, y5 - mean(x), \n                             label = sprintf(\"y = %.3g + _x_\", \n                                             after_stat(b_0))), \n               parse = TRUE,\n               output.type = \"numeric\",\n               formula = y ~ 1, \n               geom = \"richtext\", hjust = 0, vjust = 1) +\n  geom_point(mapping = aes(x, y5), size = 2.5) +\n  ylab(\"y\")\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-36-1.svg){fig-align='center'}\n:::\n:::\n\n:::\n\nRegressions of *y* on *x* and *x* on *y* in the same plot. The lines are\ndrawn for the range of the explanatory variable, which differs in this\ncase between the two fits.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# the default for formula is y ~ x\nggplot(df3, aes(x, y)) +\n  geom_point() +\n  stat_poly_line(color = \"blue\") +\n  stat_poly_eq(mapping = use_label(\"R2\", \"eq\", sep = \", \"), \n               color = \"blue\", geom = \"richtext\", hjust = 0, vjust = 1) +\n  stat_poly_line(color = \"red\", \n                 orientation = \"y\") +\n  stat_poly_eq(mapping = use_label(\"R2\", \"eq\", sep = \", \"), \n               color = \"red\", \n               orientation = \"y\",\n               label.y = 11, geom = \"richtext\", hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-37-1.svg){fig-align='center'}\n:::\n:::\n\n\n## Alternatives\n\n::: callout-tip\nPackage 'ggpubr' provides a renamed copy of `stat_poly_eq()` taken from\nan old version of [ggpmisc](https://docs.r4photobiology.info/ggpmisc/). The version in 'ggpubr' is much more\nlimited in its functionality and even contains bugs. The line drawing\ncode in `stat_smooth()` from [ggplot2](https://ggplot2.tidyverse.org/) was used as a basis for\n`stat_poly_line()`, the main difference is that by default it uses\n`lm()` as method irrespective of the data size while `stat_smooth()`\nswitches to using splines for large numbers of observations.\n:::\n\n# Major axis regression\n\nIf *x* and *y* are both subject to random errors, and none is clearly\nthe cause of the other, we should use major axis regression instead of\nlinear regression.\n\nThe examples in this section make use of `stat_ma_line()` and `stat_ma_eq()`\nfrom package [ggpmisc](https://docs.r4photobiology.info/ggpmisc/).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(df3, aes(x, y)) +\n  geom_point() +\n  stat_ma_line() +\n  stat_ma_eq(mapping = use_label(\"R2\", \"eq\", sep = \", \"), \n             geom = \"richtext\", hjust = 0)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-38-1.svg){fig-align='center'}\n:::\n:::\n\n\n::: callout-tip\nNo alternatives I know of.\n:::\n\n# Quantile regression\n\nQuantile regression is frequently used is some disciplines like\nEconomics but less frequently in other fields. It is robust and can be\nrather easily interpreted based on its similarity to the well known box\nplots.\n\nThe examples in this section make use of `stat_quant_line()`,\n`stat_quant_band()` and `stat_quant_eq()` from package [ggpmisc](https://docs.r4photobiology.info/ggpmisc/).\n\n::: callout-caution\nQuantile regression fits are done by numerical approximation, and\nfrequently generate warnings for non-unique solutions or similar\nproblems. Their importance needs to be assessed by users. In the\nexamples below they seem mostly unimportant given the large number of\nobservations and have been silenced in the output.\n:::\n\nA median regression with a band limited by the upper and lower quartile\nregressions.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# the default for formula is y ~ x\nggplot(df3, aes(x, y)) +\n  geom_point() +\n  stat_quant_band() +\n  stat_quant_eq(quantiles = 0.5, geom = \"richtext\", hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-39-1.svg){fig-align='center'}\n:::\n:::\n\n\nMedian regression through the origin.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# model with intercept = 0\nformula <- y ~ x + 0\nggplot(df3, aes(x, y)) +\n  geom_point() +\n  stat_quant_band(formula = formula) +\n  stat_quant_eq(formula = formula, quantiles = 0.5, \n                geom = \"richtext\", hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-40-1.svg){fig-align='center'}\n:::\n:::\n\n\nQuantile regressions of _y_ on _x_ and _x_ on _y_.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# the default for formula is y ~ x\nggplot(df3, aes(x, y)) +\n  geom_point() +\n  stat_quant_band(color = \"blue\") +\n  stat_quant_eq(quantiles = 0.5, color = \"blue\", \n                geom = \"richtext\", hjust = 0, vjust = 1) +\n  stat_quant_band(color = \"red\", \n                  orientation = \"y\") +\n  stat_quant_eq(quantiles = 0.5, color = \"red\", \n                orientation = \"y\", label.y = 11, \n                geom = \"richtext\", hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-41-1.svg){fig-align='center'}\n:::\n:::\n\n\nFitting a polynomial by quantile regression.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(df2, aes(x, y)) +\n  geom_point() +\n  stat_quant_band(formula = y ~ poly(x, 2, raw = TRUE)) +\n  stat_quant_eq(formula = y ~ poly(x, 2, raw = TRUE), quantiles = 0.5,\n                geom = \"richtext\", hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-42-1.svg){fig-align='center'}\n:::\n:::\n\n\nTwo quantiles are by default plotted as lines,\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(df2, aes(x, y)) +\n  geom_point() +\n  stat_quant_line(formula = y ~ poly(x, 2, raw = TRUE), quantiles = c(0.05, 0.95)) +\n  stat_quant_eq(formula = y ~ poly(x, 2, raw = TRUE), quantiles = c(0.05, 0.95), \n                geom = \"richtext\", hjust = 0, vjust = 1, vstep = 0.1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-43-1.svg){fig-align='center'}\n:::\n:::\n\n\nA single quantile, here the median, is plotted as a line plus a\nconfidence band.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(df2, aes(x, y)) +\n  geom_point() +\n  stat_quant_line(formula = y ~ poly(x, 2, raw = TRUE), quantiles = 0.5) +\n  stat_quant_eq(formula = y ~ poly(x, 2, raw = TRUE), quantiles = 0.5, \n                geom = \"richtext\", hjust = 0, vjust = 1)\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-44-1.svg){fig-align='center'}\n:::\n:::\n\n\nEquations labelled by quantile. (This code works only with 'ggpmisc' > 0.5.6,\nwhen `qtl.label` was added. Use `grp.label` with earlier versions.)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(df2, aes(x, y)) +\n  geom_point() +\n  stat_quant_band(formula = y ~ poly(x, 2, raw = TRUE), \n                  color = \"black\", fill = \"grey60\") +\n  stat_quant_eq(aes(label = paste(after_stat(qtl.label), \": \",\n                                  after_stat(eq.label), sep = \"\")),\n                formula = y ~ poly(x, 2, raw = TRUE), \n                geom = \"richtext\", hjust = 0, vjust = 1, vstep = 0.1) +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-45-1.svg){fig-align='center'}\n:::\n:::\n\n\nEquations labelled by group and quantile. (This code works only with 'ggpmisc' > 0.5.6, when `qtl.label` was added. Use only `grp.label` with earlier versions.)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(df2, aes(x, y, group = group, linetype = group, \n                    shape = group, grp.label = group)) +\n  geom_point() +\n  stat_quant_line(formula = y ~ poly(x, 2, raw = TRUE), \n                  quantiles = c(0.1, 0.9), \n                  color = \"black\") +\n  stat_quant_eq(aes(label = paste(after_stat(grp.label), \" \",\n                                  after_stat(qtl.label), \": \",\n                                  after_stat(eq.label), sep = \"\")),\n                formula = y ~ poly(x, 2, raw = TRUE), \n                quantiles = c(0.1, 0.9), \n                geom = \"richtext\", hjust = 0, vjust = 1, vstep = 0.1) +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-46-1.svg){fig-align='center'}\n:::\n:::\n\n\n## Alternatives\n\n::: callout-tip\nPackage [ggplot2](https://ggplot2.tidyverse.org/) defines `stat_quantile()` which can be used to plot as\na line some types of quantile regression fits, but is less flexible than\n`stat_quant_line()` and `stat_quant_band()`.\n:::\n\n# Non-linear models\n\nThe examples in previous sections were based on ready assembled labels. Here\nwe show examples of how to generate labels for equations and other parameter\nestimates with an approach applicable to many different types of models.\n\nThe examples in this section make use of `stat_fit_tidy()` from package\n[ggpmisc](https://docs.r4photobiology.info/ggpmisc/).\n\nWe use as example a fit of the Michaelis-Menthen equation of reaction kinetics,\na function that is non-linear in its parameters.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"false\"}\n# We use methods from package 'broom'\nlibrary(broom)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmicmen.formula <- y ~ SSmicmen(x, Vm, K) \nggplot(Puromycin, aes(conc, rate, colour = state)) +\n  geom_point() +\n  geom_smooth(method = \"nls\", \n              formula = micmen.formula,\n              se = FALSE) +\n  stat_fit_tidy(method = \"nls\", \n                method.args = list(formula = micmen.formula),\n                label.x = \"right\",\n                label.y = \"bottom\",\n                aes(label = paste(\"V<sub>m</sub> = \", signif(after_stat(Vm_estimate), digits = 3),\n                                  \"&plusmn;\", signif(after_stat(Vm_se), digits = 2),\n                                  \"  K = \", signif(after_stat(K_estimate), digits = 3),\n                                  \"&plusmn;\", signif(after_stat(K_se), digits = 2),\n                                  sep = \"\")), \n                geom = \"richtext\", hjust = 1, vstep = 0.1) +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](plot-equations-markdown_files/figure-html/unnamed-chunk-48-1.svg){fig-align='center'}\n:::\n:::\n\n\n## Alternatives\n\n::: callout-tip\nIn all cases it is possible to do the model fitting before creating the plot, assembling\nlabels in one's own R code and passing them to `ggplot()` as data. The\npossibilities are nearly unlimited but implementing them, depending on one's\nown familiarity with R and 'ggplot2' can become very time consuming. I have\nin part written [ggpp](https://docs.r4photobiology.info/ggpp/) and [ggpmisc](https://docs.r4photobiology.info/ggpmisc/) to avoid as a user having to remind\nmyself of how to write such code repeatedly. My hope is that others will also\nsave time and effort by using the packages I have developed.\n:::\n",
    "supporting": [
      "plot-equations-markdown_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}