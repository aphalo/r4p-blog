---
title: "Multiple comparisons with 'ggpmisc'"
subtitle: "Letter labels and labelled bars"
author: "Pedro J. Aphalo"
date: "2023-08-04"
date-modified: "2023-08-04"
keywords: [ggplot2 pkg, ggpp pkg, ggpmisc pkg, data labels, plot annotations, pairwise]
categories: [Plotting examples]
abstract: |
  Examples of plots with pairwise labels and letter labels created with `stat_multcomp()` from R package 'ggpmisc'. Function `stat_multcomp()` computes and adds to ggplots the results from multiple comparison tests as labels. Multiple comparisons based on Tukey and Dunnet contrasts are demonstrated.
editor: 
  markdown: 
    wrap: 72
code-fold: true
format:
  html: 
    code-link: true
    code-tools: true
draft: true
---

::: callout-warning
The examples in this page make use of of package
'ggpmisc' (>= 0.5.4) and 'ggpp' (>= 0.5.4) available through CRAN. Earlier
versions lack the layer functions used.
:::

::: callout-tip
In this page most code chunks are "folded" so as to decrease the clutter when
searching for examples. A few code chunks that are reused across several plots
are by default unfolded to make them more visible. Above each plot you will find
one or more "folded" code chuncks signalled by a small triangle followed by
"Code". Clicking on the triangle "unfolds" the code chunk making visible the R
code used to produce the plot.

The code in the chunks can be copied by clicking on the top right
corner, where an icon appears when the mouse cursor hovers over the code
listing.

The `</> Code` drop down menu to the right of the page title makes it possible
to unfold all code chunks and to view the Quarto source of the whole web page.

Names of functions and other R objects are linked to the corresponding on-line
help pages. The names of R extension packages are linked to their documentation
web sites when available.
:::

## Introduction

Here you will find examples of plots including labels based on multiple 
comparisons across levels of a factor mapped to the _x_ aesthetic. The labels have
been added to the plots with statistic `stat_mulltcomp()` defined in package
[ggpp](https://docs.r4photobiology.info/ggpmisc/) available at CRAN.

Package [ggpmisc](https://docs.r4photobiology.info/ggpmisc/) imports and 
re-exports all definitions from [ggpp](https://docs.r4photobiology.info/ggpp/)
as well as from [ggplot2](https://ggplot2.tidyverse.org/).

::: callout-important
One needs to always check that annotations do not occlude anything
significant, such as observations in the base plot. This needs special
care when using annotations together with batch plotting. Either ensure
that the scale limits of the base plot are expanded to avoid overlap or
that the layer with the multiple comparison lables is the lowest one, i.e., added to the
plot first.
:::

## Plot annotations for multiple comparison tests

Data labels add textual information directly related to individual data
points (shown as glyphs), such as original observations or summaries such as 
means. The position of labels in this case is dependent on the
scales used to represent data points. Text is usually displaced so that
it does not occlude the glyph representing the data point and when the
link to the data point is unclear, this link is signalled with a line
segment or arrow. Data labels are distinct from annotations in that they
contribute directly to the representation of data on a plot or map.

Annotations differ from data labels, in that their position is decoupled
from their meaning. Insets can be thought as larger, but still
self-contained annotations. In most cases the reading of inset tables
and plots depends only weakly on the plot or map in which they are
included.

In the case of annotations and insets the designer of a data
visualization has the freedom to locate them anywhere, as long as they
do not occlude features used to describe data.

The letter labels and labelled segments used to highlight pairwise comparisons
are a special case as they behave as data labels along the axis onto which an
explanatory factor has been mapped, usually _x_, but frequently as annotations along the
axis onto which a continuous numeric variable has been mapped, usually _y_.

::: callout-caution
Multiple comparisons are frequently applied as post-hoc tests, in many cases including all possible pairwise constrasts (Tukey contrasts) or every treatment individually against a control condition (Dunnet contrasts). As post-hoc tests, they are seen as a way of investigating the source of an overall significant difference, and multiple comparisons are applied only if the main effect of the factor is in itself significant and skipped otherwise. In other cases multiple comparisons can be the primary statistical test addressing the research hypotheses. Both approaches are valid as long as the hypotheses have been set independently of the data being used in the test. **What should be avoided is to cherry pick promising pairwise tests based on the data, and then correct the _P_-values taking into account only the cherry-picked pairs.**

When applying multiple comparisons, it is necessary to adjust the _P_-values taking into account the fact the the more numerous the tests, the more likely is that at least one or a few of them will yield false positive outcomes. There are different approaches, that can be grouped into methods that attempt control the experiment-wise probability of false positive outcomes to a given _P_-level, such as 0.05, and those that attempt to control the false discovery rate, that can be thought of as the proportion of the tests that yield false positive outcomes. There are variations in both approaches, varying in power and conservativeness.
:::

## How does `stat_multcomp()` work?

Layer function `stat_multcomp()` first fits a model (a linear model by default) followed by the multiple comparison test with a user-controlled adjustment to the _P_-values. By default `"Tukey"` contrasts are computed but `"Dunnet"` contrasts are also supported. The implementation makes use of function `glht()` from package 'multcomp' making available all the methods it supports for the adjustment of _P_-values for multiple comparisons. Currently, `stat_multcomp()` only implements pairwise contrasts, as in this case there are well established approaches to plot annotations. Contrasts other than `"Tukey"` and `"Dunnet"` are not supported.

The returned data contains both numeric and ready formatted character strings. The returned value and default geometry depend on the type of label, that can be
either bars (connecting segments) labelled with _P_-values or other parameters, or letters. With bars, plots get crowded easily, and are supported for factors with two to five levels. In contrast, encoding pairwise difference using letters can be used with factor with two or more levels.

As other layer functions in R package 'ggpmisc', `stat_multcomp()` attempts to be flexible, both in the statistical methods used to test multiple comparisons and in the way the outcomes can be shown in plots. In particular, the adjustment of _p_-values in enabled by default.

Even if flexible, it does not cater for all uses of multiple comparisons, and it is to be expected that in some cases multiple comparison tests will be applied before plotting, and the outcomes shown in plots using geometries rather than statistics. Examples of such use of `geom_text_pairwise()` are illustrated in the page [Pairwise labels with 'ggpp'](pairwise-labels.qmd).

```{r, message=FALSE}
library(ggpmisc)
theme_set(theme_bw())
```

## Using default labels

```{r}
ggplot(mpg, aes(factor(cyl), cty)) +
  stat_summary(fun.data = mean_cl_normal, colour = "red") +
  stat_multcomp(label.y = 12, 
                size = 2.75, 
                vstep = 0.05) +
  expand_limits(y = 0)
```

```{r}
ggplot(mpg, aes(factor(cyl), cty)) +
  stat_summary(fun.data = mean_cl_normal, colour = "red") +
  stat_multcomp(adjusted.type = "holm",
                label.y = 12, 
                size = 2.75, 
                vstep = 0.05) +
  expand_limits(y = 0)
```

```{r}
ggplot(mpg, aes(factor(cyl), cty)) +
  stat_summary(fun = mean, geom = "col", width = 0.5) +
  stat_summary(fun.data = mean_cl_normal, colour = "red") +
  stat_multcomp(label.y = 25, 
                size = 2.75,
                contrast.type = "Dunnet")
```

```{r}
ggplot(mpg, aes(factor(cyl), cty)) +
  stat_summary(fun = mean, geom = "col", width = 0.5) +
  stat_summary(fun.data = mean_cl_normal, colour = "red") +
  stat_multcomp(size = 2.5, label.y = 25)
```


```{r}
ggplot(mpg, aes(factor(cyl), cty)) +
  stat_summary(fun = mean, geom = "col", width = 0.5) +
  stat_summary(fun.data = mean_cl_normal, colour = "red") +
  stat_multcomp(label.y = -1, 
                label.type = "letters")
```
```{r}
ggplot(mpg, aes(factor(cyl), cty)) +
  stat_summary(fun = mean, geom = "col", width = 0.5) +
  stat_summary(fun.data = mean_cl_normal, colour = "red") +
  stat_multcomp(colour = "white", 
                label.type = "letters")
```

```{r}
ggplot(mpg, aes(factor(cyl), cty)) +
  stat_multcomp(size = 2.75) +
  stat_boxplot(width = 1/3)
```

```{r}
ggplot(mpg, aes(factor(cyl), cty)) +
  stat_multcomp(size = 2.85,
                label.y = 11,
                geom = "text_pairwise",
                vstep = 0.07,
                p.digits = 2,
                contrast.type = "Dunnet") +
  stat_boxplot(width = 1/3) +
  expand_limits(y = 0)
```

```{r}
ggplot(mpg, aes(factor(cyl), cty)) +
  stat_multcomp(label.type = "letters",
                geom = "label") +
  stat_boxplot(width = 1/3)
```


```{r}
ggplot(mpg, aes(factor(cyl), cty)) +
  stat_summary(fun = mean, geom = "col", width = 0.5) +
  stat_summary(fun.data = mean_cl_normal, colour = "red") +
  stat_multcomp(aes(x = stage(start = factor(cyl), 
                              after_stat = x.right.tip)),
                geom = "text",
                label.y = -1, 
                vstep = 0,
                size = 3,
                contrast.type = "Dunnet")
```

## Using pre-built labels other than default


```{r}
ggplot(mpg, aes(factor(cyl), cty)) +
  stat_multcomp(use_label(c("delta", "P")),
                size = 2.75,
                label.y = 11,
                vstep = 0.08,
                p.digits = 2,
                contrast.type = "Dunnet") +
  stat_boxplot(width = 1/3) +
  expand_limits(y = 0)
```

```{r}
ggplot(mpg, aes(factor(cyl), cty)) +
  stat_multcomp(use_label(c("t", "P")),
                          size = 2.75,
                label.y = 11,
                vstep = 0.08,
                contrast.type = "Dunnet") +
  stat_boxplot(width = 1/3) +
  expand_limits(y = 0)
```

```{r}
ggplot(mpg, aes(factor(cyl), cty)) +
  stat_summary(fun = mean, geom = "col", width = 0.5) +
  stat_summary(fun.data = mean_cl_normal, colour = "red") +
  stat_multcomp(aes(x = stage(start = factor(cyl), after_stat = x.right.tip),
                    label = after_stat(stars.label)),
                geom = "text",
                label.y = -1, 
                vstep = 0,
                contrast.type = "Dunnet")
```

## Using other aesthetics

```{r}
ggplot(mpg, aes(factor(cyl), cty)) +
  stat_multcomp(aes(colour = after_stat(p.value) < 0.05),
                size = 2.75,
                label.y = 11,
                vstep = 0.08,
                p.digits = 2,
                contrast.type = "Dunnet") +
  stat_boxplot(width = 1/3) +
  scale_colour_manual(values = c("grey50", "blue")) +
  expand_limits(y = 0)
```

```{r}
ggplot(mpg, aes(factor(cyl), cty)) +
  stat_multcomp(aes(fill = after_stat(p.value) < 0.05),
                size = 2.75,
                label.y = 11,
                vstep = 0.08,
                p.digits = 2,
                contrast.type = "Dunnet") +
  stat_boxplot(width = 1/3) +
  scale_fill_manual(values = c("grey90", "lightblue")) +
  expand_limits(y = 0)
```

```{r}
ggplot(mpg, aes(factor(cyl), cty)) +
  stat_multcomp(aes(colour = factor(after_stat(letters.label))),
                label.type = "letters",
                size = 5) +
  stat_boxplot(width = 1/3) +
  expand_limits(y = 0)
```


```{r}
ggplot(mpg, aes(factor(cyl), cty)) +
  stat_multcomp(aes(colour = factor(after_stat(letters.label))),
                label.type = "letters",
                geom = "point",
                size = 3) +
  stat_boxplot(width = 1/3) +
  expand_limits(y = 0)
```
